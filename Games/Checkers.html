<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Checkers Game - 40x16</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            max-width: 1400px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        button {
            padding: 10px 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s, transform 0.1s;
        }

        button:hover {
            background: #5568d3;
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .game-setup {
            margin-bottom: 20px;
            padding: 20px;
            background: #f5f5f5;
            border-radius: 10px;
        }

        .mode-select, .player-names, .ai-level {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #333;
        }

        select, input {
            width: 100%;
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        select:focus, input:focus {
            outline: none;
            border-color: #667eea;
        }

        .game-area {
            display: flex;
            gap: 20px;
            justify-content: center;
            align-items: flex-start;
            flex-wrap: wrap;
        }

        .board-container {
            position: relative;
            overflow-x: auto;
            max-width: 100%;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(40, 25px);
            grid-template-rows: repeat(16, 25px);
            border: 4px solid #333;
            border-radius: 5px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            background: #fff;
            margin: 0 auto;
        }

        .square {
            width: 25px;
            height: 25px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            position: relative;
            transition: background 0.2s ease;
        }

        .square.light {
            background: #f0d9b5;
        }

        .square.dark {
            background: #b58863;
        }

        .square.selected {
            background: #7fc97f !important;
            box-shadow: inset 0 0 8px rgba(0,0,0,0.4);
            border: 2px solid #2d6a2d;
        }

        .square.valid-move {
            background: #ffffaa !important;
            position: relative;
            cursor: pointer;
        }

        .square.valid-move::after {
            content: '';
            position: absolute;
            width: 10px;
            height: 10px;
            background: rgba(102, 126, 234, 0.7);
            border-radius: 50%;
            pointer-events: none;
            box-shadow: 0 0 4px rgba(102, 126, 234, 0.8);
        }

        .square.valid-move:hover {
            background: #ffff66 !important;
            transform: scale(1.1);
        }

        .piece {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid #333;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 12px;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .piece:hover {
            transform: scale(1.2);
            box-shadow: 0 4px 8px rgba(0,0,0,0.5);
        }

        .piece.red {
            background: radial-gradient(circle at 30% 30%, #ff6b6b, #c92a2a);
        }

        .piece.black {
            background: radial-gradient(circle at 30% 30%, #495057, #212529);
        }

        .piece.king::before {
            content: '‚ôî';
            color: gold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .info-panel {
            background: #f5f5f5;
            padding: 20px;
            border-radius: 10px;
            min-width: 250px;
        }

        .status {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
            padding: 10px;
            background: white;
            border-radius: 5px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .score {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding: 10px;
            background: white;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .score-item {
            text-align: center;
        }

        .score-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
        }

        .score-value {
            font-size: 24px;
            font-weight: bold;
        }

        .ai-info {
            margin-top: 10px;
            padding: 10px;
            background: white;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            font-size: 12px;
            color: #666;
            text-align: center;
        }

        .difficulty-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 11px;
            margin-left: 5px;
        }

        .difficulty-easy {
            background: #51cf66;
            color: white;
        }

        .difficulty-medium {
            background: #ffd43b;
            color: #333;
        }

        .difficulty-hard {
            background: #ff6b6b;
            color: white;
        }

        .paused-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 5px;
            backdrop-filter: blur(4px);
        }

        .paused-text {
            color: white;
            font-size: 36px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .hidden {
            display: none;
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            .board {
                grid-template-columns: repeat(40, 20px);
                grid-template-rows: repeat(16, 20px);
            }
            
            .square {
                width: 20px;
                height: 20px;
            }
            
            .piece {
                width: 16px;
                height: 16px;
                font-size: 10px;
            }
            
            .info-panel {
                min-width: 100%;
            }
            
            h1 {
                font-size: 24px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéØ Checkers Game - 40x16 Board</h1>
        
        <div class="game-setup" id="setup">
            <div class="mode-select">
                <label>Game Mode:</label>
                <select id="gameMode" onchange="toggleAILevel()">
                    <option value="pvp">Player vs Player</option>
                    <option value="pva">Player vs AI</option>
                    <option value="ava">AI vs AI</option>
                </select>
            </div>

            <div class="ai-level" id="aiLevelSelect" style="display: none;">
                <label>AI Difficulty:</label>
                <select id="aiDifficulty">
                    <option value="easy">üü¢ ‡∏á‡πà‡∏≤‡∏¢ (Easy) - ‡∏™‡∏∏‡πà‡∏°‡πÄ‡∏î‡∏¥‡∏ô</option>
                    <option value="medium" selected>üü° ‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á (Medium) - ‡∏ß‡∏≤‡∏á‡πÅ‡∏ú‡∏ô 2 ‡∏Å‡πâ‡∏≤‡∏ß</option>
                    <option value="hard">üî¥ ‡∏¢‡∏≤‡∏Å (Hard) - ‡∏ß‡∏≤‡∏á‡πÅ‡∏ú‡∏ô 4 ‡∏Å‡πâ‡∏≤‡∏ß</option>
                </select>
            </div>
            
            <div class="player-names">
                <label>Red Player Name:</label>
                <input type="text" id="redName" value="Red Player">
                <label style="margin-top: 10px;">Black Player Name:</label>
                <input type="text" id="blackName" value="Black Player">
            </div>
            
            <button onclick="startGame()" style="width: 100%; margin-top: 10px;">Start Game</button>
        </div>

        <div class="controls">
            <button onclick="newGame()">New Game</button>
            <button onclick="togglePause()" id="pauseBtn">Pause</button>
            <button onclick="showSetup()">Change Settings</button>
        </div>

        <div class="game-area">
            <div class="board-container">
                <div class="board" id="board"></div>
                <div class="paused-overlay hidden" id="pausedOverlay">
                    <div class="paused-text">PAUSED</div>
                </div>
            </div>

            <div class="info-panel">
                <div class="status" id="status">Red's Turn</div>
                <div class="score">
                    <div class="score-item">
                        <div class="score-label" id="redLabel">Red</div>
                        <div class="score-value" style="color: #c92a2a;" id="redScore">60</div>
                    </div>
                    <div class="score-item">
                        <div class="score-label" id="blackLabel">Black</div>
                        <div class="score-value" style="color: #212529;" id="blackScore">60</div>
                    </div>
                </div>
                <div class="ai-info" id="aiInfo" style="display: none;"></div>
            </div>
        </div>
    </div>

    <script>
        const ROWS = 16;
        const COLS = 40;
        
        let board = [];
        let currentPlayer = 'red';
        let selectedPiece = null;
        let validMoves = [];
        let gameMode = 'pvp';
        let aiDifficulty = 'medium';
        let isPaused = false;
        let redName = 'Red Player';
        let blackName = 'Black Player';
        let captureSequence = false;

        function toggleAILevel() {
            const mode = document.getElementById('gameMode').value;
            const aiLevelDiv = document.getElementById('aiLevelSelect');
            if (mode === 'pva' || mode === 'ava') {
                aiLevelDiv.style.display = 'block';
            } else {
                aiLevelDiv.style.display = 'none';
            }
        }

        function initBoard() {
            board = Array(ROWS).fill(null).map(() => Array(COLS).fill(null));
            
            // Place red pieces (top 5 rows)
            for (let row = 0; row < 5; row++) {
                for (let col = 0; col < COLS; col++) {
                    if ((row + col) % 2 === 1) {
                        board[row][col] = { color: 'red', king: false };
                    }
                }
            }
            
            // Place black pieces (bottom 5 rows)
            for (let row = ROWS - 5; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    if ((row + col) % 2 === 1) {
                        board[row][col] = { color: 'black', king: false };
                    }
                }
            }
        }

        function renderBoard() {
            const boardEl = document.getElementById('board');
            boardEl.innerHTML = '';
            
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    const square = document.createElement('div');
                    square.className = 'square ' + ((row + col) % 2 === 0 ? 'light' : 'dark');
                    square.dataset.row = row;
                    square.dataset.col = col;
                    
                    if (selectedPiece && selectedPiece.row === row && selectedPiece.col === col) {
                        square.classList.add('selected');
                    }
                    
                    if (validMoves.some(m => m.row === row && m.col === col)) {
                        square.classList.add('valid-move');
                    }
                    
                    const piece = board[row][col];
                    if (piece) {
                        const pieceEl = document.createElement('div');
                        pieceEl.className = `piece ${piece.color}`;
                        if (piece.king) {
                            pieceEl.classList.add('king');
                        }
                        square.appendChild(pieceEl);
                    }
                    
                    square.addEventListener('click', () => handleSquareClick(row, col));
                    boardEl.appendChild(square);
                }
            }
            
            updateScore();
        }

        function handleSquareClick(row, col) {
            if (isPaused) return;
            
            if (gameMode === 'ava') return;
            if (gameMode === 'pva' && currentPlayer === 'black') return;
            
            const piece = board[row][col];
            
            if (selectedPiece) {
                const move = validMoves.find(m => m.row === row && m.col === col);
                if (move) {
                    const wasCapture = move.capture !== undefined;
                    makeMove(selectedPiece.row, selectedPiece.col, row, col);
                    
                    if (wasCapture) {
                        const nextCaptures = getCaptureMoves(row, col);
                        if (nextCaptures.length > 0) {
                            selectedPiece = { row, col };
                            validMoves = nextCaptures;
                            captureSequence = true;
                            renderBoard();
                            return;
                        }
                    }
                    
                    selectedPiece = null;
                    validMoves = [];
                    captureSequence = false;
                    switchPlayer();
                } else if (piece && piece.color === currentPlayer && !captureSequence) {
                    selectedPiece = { row, col };
                    validMoves = getValidMoves(row, col);
                    renderBoard();
                } else {
                    selectedPiece = null;
                    validMoves = [];
                    renderBoard();
                }
            } else if (piece && piece.color === currentPlayer) {
                selectedPiece = { row, col };
                validMoves = getValidMoves(row, col);
                renderBoard();
            }
        }

        function getCaptureMoves(row, col) {
            const piece = board[row][col];
            if (!piece) return [];
            
            const captures = [];
            const directions = piece.king ? 
                [[-1, -1], [-1, 1], [1, -1], [1, 1]] :
                piece.color === 'red' ? [[1, -1], [1, 1]] : [[-1, -1], [-1, 1]];
            
            for (const [dRow, dCol] of directions) {
                const newRow = row + dRow;
                const newCol = col + dCol;
                
                if (newRow >= 0 && newRow < ROWS && newCol >= 0 && newCol < COLS) {
                    const target = board[newRow][newCol];
                    if (target && target.color !== piece.color) {
                        const jumpRow = newRow + dRow;
                        const jumpCol = newCol + dCol;
                        if (jumpRow >= 0 && jumpRow < ROWS && jumpCol >= 0 && jumpCol < COLS && !board[jumpRow][jumpCol]) {
                            captures.push({ row: jumpRow, col: jumpCol, capture: { row: newRow, col: newCol } });
                        }
                    }
                }
            }
            
            return captures;
        }

        function getValidMoves(row, col) {
            const piece = board[row][col];
            if (!piece || piece.color !== currentPlayer) return [];
            
            const captures = getCaptureMoves(row, col);
            if (captures.length > 0) return captures;
            
            const anyCaptures = getAllCaptureMoves(currentPlayer);
            if (anyCaptures.length > 0) return [];
            
            const moves = [];
            const directions = piece.king ? 
                [[-1, -1], [-1, 1], [1, -1], [1, 1]] :
                piece.color === 'red' ? [[1, -1], [1, 1]] : [[-1, -1], [-1, 1]];
            
            for (const [dRow, dCol] of directions) {
                const newRow = row + dRow;
                const newCol = col + dCol;
                
                if (newRow >= 0 && newRow < ROWS && newCol >= 0 && newCol < COLS && !board[newRow][newCol]) {
                    moves.push({ row: newRow, col: newCol });
                }
            }
            
            return moves;
        }

        function getAllCaptureMoves(color) {
            const captures = [];
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    const piece = board[row][col];
                    if (piece && piece.color === color) {
                        const pieceMoves = getCaptureMoves(row, col);
                        if (pieceMoves.length > 0) {
                            captures.push(...pieceMoves);
                        }
                    }
                }
            }
            return captures;
        }

        function makeMove(fromRow, fromCol, toRow, toCol) {
            const piece = board[fromRow][fromCol];
            board[toRow][toCol] = piece;
            board[fromRow][fromCol] = null;
            
            const move = validMoves.find(m => m.row === toRow && m.col === toCol);
            if (move && move.capture) {
                board[move.capture.row][move.capture.col] = null;
            }
            
            if ((piece.color === 'red' && toRow === ROWS - 1) || (piece.color === 'black' && toRow === 0)) {
                piece.king = true;
            }
            
            renderBoard();
        }

        function evaluateBoard(color) {
            let score = 0;
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    const piece = board[row][col];
                    if (piece) {
                        let pieceValue = piece.king ? 3 : 1;
                        
                        if (piece.color === 'red') {
                            pieceValue += (ROWS - 1 - row) * 0.05;
                        } else {
                            pieceValue += row * 0.05;
                        }
                        
                        const centerDist = Math.abs((COLS / 2) - col);
                        pieceValue += ((COLS / 2) - centerDist) * 0.02;
                        
                        if (piece.color === color) {
                            score += pieceValue;
                        } else {
                            score -= pieceValue;
                        }
                    }
                }
            }
            return score;
        }

        function minimax(depth, isMaximizing, alpha, beta, color) {
            if (depth === 0) {
                return evaluateBoard(color);
            }
            
            const moves = getAllPossibleMoves(isMaximizing ? color : (color === 'red' ? 'black' : 'red'));
            
            if (moves.length === 0) {
                return isMaximizing ? -1000 : 1000;
            }
            
            if (isMaximizing) {
                let maxEval = -Infinity;
                for (const move of moves) {
                    const boardCopy = JSON.parse(JSON.stringify(board));
                    applyMove(move);
                    const evaluation = minimax(depth - 1, false, alpha, beta, color);
                    board = boardCopy;
                    maxEval = Math.max(maxEval, evaluation);
                    alpha = Math.max(alpha, evaluation);
                    if (beta <= alpha) break;
                }
                return maxEval;
            } else {
                let minEval = Infinity;
                for (const move of moves) {
                    const boardCopy = JSON.parse(JSON.stringify(board));
                    applyMove(move);
                    const evaluation = minimax(depth - 1, true, alpha, beta, color);
                    board = boardCopy;
                    minEval = Math.min(minEval, evaluation);
                    beta = Math.min(beta, evaluation);
                    if (beta <= alpha) break;
                }
                return minEval;
            }
        }

        function getAllPossibleMoves(color) {
            const allMoves = [];
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    const piece = board[row][col];
                    if (piece && piece.color === color) {
                        const tempCurrent = currentPlayer;
                        currentPlayer = color;
                        const moves = getValidMoves(row, col);
                        currentPlayer = tempCurrent;
                        moves.forEach(move => {
                            allMoves.push({ from: { row, col }, to: move });
                        });
                    }
                }
            }
            return allMoves;
        }

        function applyMove(move) {
            const piece = board[move.from.row][move.from.col];
            board[move.to.row][move.to.col] = piece;
            board[move.from.row][move.from.col] = null;
            
            if (move.to.capture) {
                board[move.to.capture.row][move.to.capture.col] = null;
            }
            
            if ((piece.color === 'red' && move.to.row === ROWS - 1) || (piece.color === 'black' && move.to.row === 0)) {
                piece.king = true;
            }
        }

        function switchPlayer() {
            if (checkWinner()) return;
            
            currentPlayer = currentPlayer === 'red' ? 'black' : 'red';
            const playerName = currentPlayer === 'red' ? redName : blackName;
            document.getElementById('status').textContent = `${playerName}'s Turn`;
            
            renderBoard();
            
            if ((gameMode === 'pva' && currentPlayer === 'black') || gameMode === 'ava') {
                setTimeout(makeAIMove, 500);
            }
        }

        function makeAIMove() {
            if (isPaused) return;
            
            const allMoves = getAllPossibleMoves(currentPlayer);
            
            if (allMoves.length === 0) {
                checkWinner();
                return;
            }
            
            let bestMove;
            
            if (aiDifficulty === 'easy') {
                const captureMoves = allMoves.filter(m => m.to.capture);
                const movesToConsider = captureMoves.length > 0 ? captureMoves : allMoves;
                bestMove = movesToConsider[Math.floor(Math.random() * movesToConsider.length)];
            } else if (aiDifficulty === 'medium') {
                let bestScore = -Infinity;
                for (const move of allMoves) {
                    const boardCopy = JSON.parse(JSON.stringify(board));
                    applyMove(move);
                    const score = minimax(1, false, -Infinity, Infinity, currentPlayer);
                    board = boardCopy;
                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = move;
                    }
                }
            } else {
                let bestScore = -Infinity;
                for (const move of allMoves) {
                    const boardCopy = JSON.parse(JSON.stringify(board));
                    applyMove(move);
                    const score = minimax(3, false, -Infinity, Infinity, currentPlayer);
                    board = boardCopy;
                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = move;
                    }
                }
            }
            
            selectedPiece = bestMove.from;
            validMoves = getValidMoves(bestMove.from.row, bestMove.from.col);
            renderBoard();
            
            setTimeout(() => {
                const wasCapture = bestMove.to.capture !== undefined;
                makeMove(bestMove.from.row, bestMove.from.col, bestMove.to.row, bestMove.to.col);
                
                if (wasCapture) {
                    const nextCaptures = getCaptureMoves(bestMove.to.row, bestMove.to.col);
                    if (nextCaptures.length > 0) {
                        selectedPiece = { row: bestMove.to.row, col: bestMove.to.col };
                        validMoves = nextCaptures;
                        captureSequence = true;
                        setTimeout(makeAIMove, 500);
                        return;
                    }
                }
                
                selectedPiece = null;
                validMoves = [];
                captureSequence = false;
                switchPlayer();
            }, 300);
        }

        function updateScore() {
            let redCount = 0;
            let blackCount = 0;
            
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    const piece = board[row][col];
                    if (piece) {
                        if (piece.color === 'red') redCount++;
                        else blackCount++;
                    }
                }
            }
            
            document.getElementById('redScore').textContent = redCount;
            document.getElementById('blackScore').textContent = blackCount;
        }

        function checkWinner() {
            let redCount = 0;
            let blackCount = 0;
            let redHasMoves = false;
            let blackHasMoves = false;
            
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    const piece = board[row][col];
                    if (piece) {
                        const tempCurrent = currentPlayer;
                        currentPlayer = piece.color;
                        const moves = getValidMoves(row, col);
                        currentPlayer = tempCurrent;
                        
                        if (piece.color === 'red') {
                            redCount++;
                            if (!redHasMoves && moves.length > 0) {
                                redHasMoves = true;
                            }
                        } else {
                            blackCount++;
                            if (!blackHasMoves && moves.length > 0) {
                                blackHasMoves = true;
                            }
                        }
                    }
                }
            }
            
            if (redCount === 0 || (currentPlayer === 'red' && !redHasMoves)) {
                document.getElementById('status').textContent = `${blackName} Wins! üéâ`;
                return true;
            }
            if (blackCount === 0 || (currentPlayer === 'black' && !blackHasMoves)) {
                document.getElementById('status').textContent = `${redName} Wins! üéâ`;
                return true;
            }
            
            return false;
        }

        function startGame() {
            gameMode = document.getElementById('gameMode').value;
            aiDifficulty = document.getElementById('aiDifficulty').value;
            redName = document.getElementById('redName').value || 'Red Player';
            blackName = document.getElementById('blackName').value || 'Black Player';
            
            document.getElementById('redLabel').textContent = redName;
            document.getElementById('blackLabel').textContent = blackName;
            document.getElementById('setup').classList.add('hidden');
            
            const aiInfo = document.getElementById('aiInfo');
            if (gameMode === 'pva' || gameMode === 'ava') {
                let difficultyText = '';
                let difficultyClass = '';
                if (aiDifficulty === 'easy') {
                    difficultyText = '‡∏á‡πà‡∏≤‡∏¢';
                    difficultyClass = 'difficulty-easy';
                } else if (aiDifficulty === 'medium') {
                    difficultyText = '‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á';
                    difficultyClass = 'difficulty-medium';
                } else {
                    difficultyText = '‡∏¢‡∏≤‡∏Å';
                    difficultyClass = 'difficulty-hard';
                }
                
                if (gameMode === 'pva') {
                    aiInfo.innerHTML = `AI: ${blackName} <span class="${difficultyClass} difficulty-badge">${difficultyText}</span>`;
                } else {
                    aiInfo.innerHTML = `Both players are AI <span class="${difficultyClass} difficulty-badge">${difficultyText}</span>`;
                }
                aiInfo.style.display = 'block';
            } else {
                aiInfo.style.display = 'none';
            }
            
            newGame();
        }

        function newGame() {
            currentPlayer = 'red';
            selectedPiece = null;
            validMoves = [];
            captureSequence = false;
            isPaused = false;
            
            document.getElementById('pauseBtn').textContent = 'Pause';
            document.getElementById('pausedOverlay').classList.add('hidden');
            
            initBoard();
            renderBoard();
            
            const playerName = currentPlayer === 'red' ? redName : blackName;
            document.getElementById('status').textContent = `${playerName}'s Turn`;
            
            if (gameMode === 'ava') {
                setTimeout(makeAIMove, 1000);
            }
        }

        function togglePause() {
            isPaused = !isPaused;
            const pauseBtn = document.getElementById('pauseBtn');
            const overlay = document.getElementById('pausedOverlay');
            
            if (isPaused) {
                pauseBtn.textContent = 'Resume';
                overlay.classList.remove('hidden');
            } else {
                pauseBtn.textContent = 'Pause';
                overlay.classList.add('hidden');
                
                if ((gameMode === 'pva' && currentPlayer === 'black') || gameMode === 'ava') {
                    setTimeout(makeAIMove, 500);
                }
            }
        }

        function showSetup() {
            document.getElementById('setup').classList.remove('hidden');
            isPaused = true;
            document.getElementById('pausedOverlay').classList.remove('hidden');
        }

        initBoard();
        renderBoard();
    </script>
</body>
</html>