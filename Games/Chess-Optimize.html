<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Chess Game - Improved</title>
<style>
  :root {
    --primary-color: #222;
    --accent-color: #66f;
    --background-color: #111;
    --light-color: #fff;
    --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
  }
  * {
    box-sizing: border-box;
  }
  body {
    margin: 0;
    font-family: var(--font-family);
    background-color: var(--background-color);
    color: var(--light-color);
    display: flex;
    flex-direction: column;
    height: 100vh;
    height: 100dvh;
    user-select: none;
    overflow: hidden;
    position: fixed;
    width: 100%;
    top: 0;
    left: 0;
  }
  #header {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    justify-content: space-between;
    padding: clamp(0.3em, 1.5vw, 0.8em);
    background-color: var(--primary-color);
    gap: 0.3em;
    flex-shrink: 0;
  }
  @media (max-width: 768px) {
    #header {
      flex-direction: column;
      padding: clamp(0.4em, 2vw, 0.6em);
    }
  }
  @media (orientation: landscape) and (max-height: 600px) {
    #header {
      padding: 0.2em 0.5em;
      gap: 0.2em;
    }
  }
  #playerNames {
    display: flex;
    flex: 1;
    justify-content: space-around;
    gap: clamp(0.3em, 1.5vw, 0.8em);
    margin: 0.3em 0;
    flex-wrap: wrap;
  }
  #playerNames button {
    background: none;
    border: 1px solid var(--light-color);
    border-radius: 4px;
    padding: clamp(0.25em, 0.8vw, 0.4em) clamp(0.4em, 1.5vw, 0.8em);
    cursor: pointer;
    font-size: clamp(0.7rem, 1.8vw, 0.95rem);
    color: var(--light-color);
    transition: all 0.2s;
  }
  @media (orientation: landscape) and (max-height: 600px) {
    #playerNames button {
      font-size: clamp(0.65rem, 1.5vw, 0.85rem);
      padding: 0.2em 0.5em;
    }
  }
  #playerNames button:hover {
    background-color: rgba(255,255,255,0.1);
  }
  #controls {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 0.5em;
  }
  button {
    background-color: var(--accent-color);
    border: none;
    border-radius: 4px;
    padding: clamp(0.3em, 1.2vw, 0.5em) clamp(0.6em, 1.8vw, 1em);
    font-size: clamp(0.75rem, 1.8vw, 1rem);
    cursor: pointer;
    color: var(--light-color);
    transition: background-color 0.2s;
  }
  @media (orientation: landscape) and (max-height: 600px) {
    button {
      font-size: clamp(0.7rem, 1.5vw, 0.9rem);
      padding: 0.25em 0.7em;
    }
  }
  button:hover {
    background-color: #88f;
  }
  button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
  #status {
    text-align: center;
    font-size: clamp(1rem, 3.5vw, 1.8rem);
    margin: clamp(0.3em, 1vw, 0.5em) 0;
    min-height: clamp(1.8em, 5vh, 2.5em);
    padding: clamp(0.3em, 1vw, 0.5em);
    flex-shrink: 0;
  }
  @media (max-width: 768px) {
    #status {
      font-size: clamp(0.9rem, 4.5vw, 1.4rem);
      min-height: clamp(1.5em, 4vh, 2em);
    }
  }
  @media (orientation: landscape) and (max-height: 600px) {
    #status {
      font-size: clamp(0.85rem, 3vw, 1.2rem);
      min-height: 1.5em;
      margin: 0.2em 0;
      padding: 0.2em;
    }
  }
  #boardContainer {
    flex: 1;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: clamp(0.3em, 1.5vw, 0.8em);
    min-height: 0;
    overflow: hidden;
  }
  #chessBoard {
    display: grid;
    grid-template-columns: repeat(8, 1fr);
    aspect-ratio: 1/1;
    max-width: min(92vmin, 95vw, 650px);
    max-height: min(92vmin, 70vh, 650px);
    width: 100%;
    height: 100%;
    border: clamp(2px, 0.4vw, 3px) solid var(--light-color);
    box-shadow: 0 4px 20px rgba(0,0,0,0.5);
    will-change: transform;
  }
  @media (max-width: 768px) {
    #chessBoard {
      max-width: min(95vw, 95vmin);
      max-height: min(95vw, 95vmin);
    }
  }
  @media (orientation: landscape) and (max-height: 600px) {
    #boardContainer {
      padding: 0.2em;
    }
    #chessBoard {
      max-width: min(85vmin, 90vw, 500px);
      max-height: min(85vmin, 75vh, 500px);
    }
  }
  @media (min-width: 1024px) and (max-width: 1366px) {
    #chessBoard {
      max-width: min(75vmin, 600px);
      max-height: min(75vmin, 600px);
    }
  }
  @media (min-width: 1367px) {
    #chessBoard {
      max-width: 700px;
      max-height: 700px;
    }
  }
  .cell {
    width: 100%;
    aspect-ratio: 1/1;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: clamp(1.8rem, 7vmin, 4.5rem);
    cursor: pointer;
    user-select: none;
    transition: transform 0.15s ease-out;
    will-change: transform;
  }
  .cell:hover:not(.disabled) {
    transform: scale(1.08);
  }
  @media (max-width: 768px) {
    .cell {
      font-size: clamp(1.5rem, 9vw, 3rem);
    }
  }
  @media (orientation: landscape) and (max-height: 600px) {
    .cell {
      font-size: clamp(1.3rem, 6vmin, 2.5rem);
    }
  }
  @media (min-width: 769px) and (max-width: 1024px) {
    .cell {
      font-size: clamp(2rem, 6vmin, 4rem);
    }
  }
  @media (min-width: 1025px) and (max-width: 1366px) {
    .cell {
      font-size: clamp(2.5rem, 5.5vmin, 5rem);
    }
  }
  @media (min-width: 1367px) {
    .cell {
      font-size: clamp(3rem, 5vmin, 6rem);
    }
  }
  .cell.white {
    background-color: #eee;
  }
  .cell.black {
    background-color: #555;
  }
  .cell.highlight {
    background: radial-gradient(circle, rgba(0, 255, 0, 0.4) 0%, transparent 70%);
    box-shadow: inset 0 0 0 3px #0f0;
  }
  .cell.lastMove {
    background: radial-gradient(circle, rgba(255, 215, 0, 0.5) 0%, transparent 70%);
    box-shadow: inset 0 0 0 3px #ffd700;
  }
  .cell.selected {
    background: radial-gradient(circle, rgba(0, 150, 255, 0.6) 0%, transparent 70%);
    box-shadow: inset 0 0 0 4px #0096ff;
  }
  .cell.can-capture {
    background: radial-gradient(circle, rgba(255, 50, 50, 0.5) 0%, transparent 70%);
    box-shadow: inset 0 0 0 3px #ff3232;
  }
  .piece-white {
    color: #fff;
    text-shadow: 0 0 5px #000, 0 0 8px #00f, 0 0 12px #00f;
    filter: drop-shadow(3px 3px 3px rgba(0,0,0,0.9));
    font-size: 1.1em;
  }
  .piece-black {
    color: #000;
    text-shadow: 0 0 5px #f00, 0 0 8px #f00, 0 0 12px #f00;
    filter: drop-shadow(3px 3px 3px rgba(255,0,0,0.6));
    font-size: 1.1em;
  }
  @media (max-width: 768px) {
    .piece-white, .piece-black {
      font-size: 1em;
    }
  }
  #bottomPanel {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1em;
    padding: clamp(0.5em, 2vw, 1em);
  }
  #countdown {
    font-size: clamp(1.5rem, 4vw, 2.2rem);
    font-weight: bold;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    padding: clamp(0.6em, 2vw, 0.8em) clamp(1.2em, 3vw, 1.8em);
    border-radius: 12px;
    box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
    border: 2px solid rgba(255, 255, 255, 0.2);
    min-width: clamp(120px, 25vw, 200px);
    text-align: center;
    transition: all 0.3s ease;
  }
  #countdown.normal {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
  }
  #countdown.medium {
    background: linear-gradient(135deg, #f6d365 0%, #fda085 100%);
    box-shadow: 0 4px 15px rgba(253, 160, 133, 0.5);
  }
  #countdown.warning {
    background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    animation: pulse 1s ease-in-out infinite;
    box-shadow: 0 4px 20px rgba(245, 87, 108, 0.6);
  }
  @keyframes pulse {
    0%, 100% {
      transform: scale(1);
    }
    50% {
      transform: scale(1.05);
    }
  }
  @media (max-width: 768px) {
    #countdown {
      font-size: clamp(1.4rem, 5vw, 2rem);
      padding: clamp(0.5em, 2.5vw, 0.8em) clamp(1em, 3.5vw, 1.5em);
      min-width: clamp(120px, 30vw, 200px);
    }
  }
  @media (orientation: landscape) and (max-height: 600px) {
    #countdown {
      font-size: clamp(1rem, 3vw, 1.4rem);
      padding: 0.3em 0.8em;
      min-width: 90px;
      border-radius: 6px;
    }
  }
  @media (min-width: 1024px) and (max-width: 1366px) {
    #countdown {
      font-size: 1.8rem;
      padding: 0.6em 1.3em;
    }
  }
  @media (min-width: 1367px) {
    #countdown {
      font-size: 2.2rem;
      padding: 0.7em 1.5em;
    }
  }
  #timeoutModal {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    padding: clamp(1.5em, 4vw, 2.5em);
    border-radius: 16px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
    z-index: 2000;
    text-align: center;
    border: 3px solid #f5576c;
    min-width: clamp(200px, 50vw, 350px);
    max-width: 90vw;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
  }
  #timeoutModal.show {
    opacity: 1;
    pointer-events: auto;
  }
  #timeoutModal h2 {
    color: #f5576c;
    font-size: clamp(1.4rem, 4.5vw, 2.2rem);
    margin: 0 0 0.5em 0;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
  }
  #timeoutModal p {
    color: #fff;
    font-size: clamp(1rem, 2.8vw, 1.3rem);
    margin: 0.5em 0;
  }
  #timeoutModal .winner {
    font-size: clamp(1.2rem, 3.5vw, 1.8rem);
    font-weight: bold;
    color: #ffd700;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
  }
  @media (orientation: landscape) and (max-height: 600px) {
    #timeoutModal {
      padding: 1em;
      min-width: clamp(180px, 40vw, 300px);
    }
    #timeoutModal h2 {
      font-size: clamp(1.2rem, 3.5vw, 1.8rem);
      margin: 0 0 0.3em 0;
    }
    #timeoutModal p {
      font-size: clamp(0.9rem, 2.5vw, 1.1rem);
      margin: 0.3em 0;
    }
    #timeoutModal .winner {
      font-size: clamp(1rem, 3vw, 1.4rem);
    }
  }
  #legend {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: clamp(0.5em, 1.5vw, 1em);
    font-size: clamp(0.65rem, 1.6vw, 0.85rem);
    opacity: 0;
    transition: opacity 0.5s ease-in-out;
    pointer-events: none;
    position: fixed;
    top: clamp(60px, 10vh, 90px);
    left: 50%;
    transform: translateX(-50%);
    background: rgba(34, 34, 34, 0.95);
    padding: clamp(0.5em, 1.5vw, 1em);
    border-radius: 8px;
    border: 2px solid var(--accent-color);
    z-index: 100;
    box-shadow: 0 4px 20px rgba(0,0,0,0.7);
    max-width: 95vw;
  }
  #legend.show {
    opacity: 1;
  }
  @media (orientation: landscape) and (max-height: 600px) {
    #legend {
      font-size: clamp(0.6rem, 1.4vw, 0.75rem);
      gap: 0.4em;
      padding: 0.4em;
      top: 50px;
    }
  }
  .legend-item {
    display: flex;
    align-items: center;
    gap: 0.3em;
  }
  .legend-box {
    width: clamp(14px, 2.5vw, 20px);
    height: clamp(14px, 2.5vw, 20px);
    border-radius: 3px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    flex-shrink: 0;
  }
  @media (orientation: landscape) and (max-height: 600px) {
    .legend-box {
      width: 12px;
      height: 12px;
    }
  }
  .legend-selected {
    background: radial-gradient(circle, rgba(0, 150, 255, 0.6) 0%, transparent 70%);
    box-shadow: inset 0 0 0 3px #0096ff;
  }
  .legend-move {
    background: radial-gradient(circle, rgba(0, 255, 0, 0.4) 0%, transparent 70%);
    box-shadow: inset 0 0 0 3px #0f0;
  }
  .legend-capture {
    background: radial-gradient(circle, rgba(255, 50, 50, 0.5) 0%, transparent 70%);
    box-shadow: inset 0 0 0 3px #ff3232;
  }
  .legend-last {
    background: radial-gradient(circle, rgba(255, 215, 0, 0.5) 0%, transparent 70%);
    box-shadow: inset 0 0 0 3px #ffd700;
  }
  #modalOverlay {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: rgba(0,0,0,0.9);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
  }
  #modal {
    background: #222;
    padding: clamp(1em, 3vw, 2em);
    border-radius: 8px;
    max-width: 90%;
    width: clamp(300px, 50vw, 400px);
    text-align: center;
    border: 2px solid var(--accent-color);
  }
  #modal h3 {
    margin-top: 0;
    color: var(--accent-color);
    font-size: clamp(1.2rem, 3vw, 1.8rem);
  }
  #modal input {
    width: 100%;
    margin: 0.5em 0;
    padding: clamp(0.4em, 1.5vw, 0.6em);
    font-size: clamp(0.9rem, 2vw, 1.1rem);
    border: 1px solid var(--accent-color);
    border-radius: 4px;
    background: #333;
    color: #fff;
  }
  #modal button {
    margin: 0.5em;
    padding: clamp(0.4em, 1.5vw, 0.6em) clamp(1em, 3vw, 1.8em);
    font-size: clamp(0.9rem, 2vw, 1.1rem);
  }
  .mode-btn {
    width: 100%;
    margin: 0.5em 0;
    padding: clamp(0.8em, 2vw, 1.2em);
    font-size: clamp(1rem, 2.5vw, 1.3rem);
    background: var(--accent-color);
    border: 2px solid transparent;
    transition: all 0.2s;
  }
  .mode-btn:hover {
    background: #88f;
    border-color: #fff;
    transform: scale(1.02);
  }
  @media (max-width: 768px) {
    #modal {
      width: 90%;
      max-width: 350px;
    }
  }
  #modeSelection, #nameInput, #aiDifficultySelection {
    display: none;
  }
  .disabled {
    pointer-events: none;
  }
</style>
</head>
<body>
<img src="https://github.com/KongNontawatDev/Black-Mourning-Ribbon/blob/2150640c0e623c7fbcca07024287b597f7999a84/ribbon_bottom_right.png?raw=true" 
     alt="Black mourning ribbon" 
     style="position:fixed; bottom:0; right:0; width:80px; opacity:0.9; z-index:9999; pointer-events:none;">  
<div id="header">
  <div id="playerNames">
    <button id="player1Btn">Player 1: <span id="player1Name">Player 1</span></button>
    <button id="player2Btn">Player 2: <span id="player2Name">Player 2</span></button>
  </div>
  <div id="controls">
    <button id="startBtn">Start Game</button>
    <button id="pauseBtn" disabled>‚∏èÔ∏è Pause</button>
    <button id="resetBtn" disabled>Reset</button>
  </div>
</div>
<div id="status">Click "Start Game" to begin</div>
<div id="boardContainer">
  <div id="chessBoard"></div>
  <div id="legend">
    <div class="legend-item">
      <div class="legend-box legend-selected"></div>
      <span>Selected Piece</span>
    </div>
    <div class="legend-item">
      <div class="legend-box legend-move"></div>
      <span>Valid Move</span>
    </div>
    <div class="legend-item">
      <div class="legend-box legend-capture"></div>
      <span>Can Capture</span>
    </div>
    <div class="legend-item">
      <div class="legend-box legend-last"></div>
      <span>Last Move</span>
    </div>
  </div>
</div>
<div id="bottomPanel">
  <div id="countdown" class="normal">Time: 10</div>
</div>

<div id="timeoutModal">
  <h2>‚è∞ TIME OUT!</h2>
  <p id="timeoutMessage"></p>
  <p class="winner" id="timeoutWinner"></p>
</div>

<div id="modalOverlay" style="display:none;">
  <div id="modal">
    <div id="modeSelection">
      <h3>Select Game Mode</h3>
      <button class="mode-btn" id="friendModeBtn">üéÆ Play with Friend</button>
      <button class="mode-btn" id="aiModeBtn">ü§ñ Play vs AI</button>
    </div>
    <div id="aiDifficultySelection">
      <h3>Select AI Difficulty</h3>
      <button class="mode-btn" id="aiEasyBtn">üòä Easy</button>
      <button class="mode-btn" id="aiHardBtn">üòà Hard</button>
      <button id="backFromDifficultyBtn">Back</button>
    </div>
    <div id="nameInput">
      <h3>Player Names</h3>
      <input type="text" id="player1Input" placeholder="Player 1 Name" />
      <input type="text" id="player2Input" placeholder="Player 2 Name" />
      <button id="saveNamesBtn">Start Game</button>
      <button id="backBtn">Back</button>
    </div>
  </div>
</div>

<script>
'use strict';

const INITIAL_FEN = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR';
const PIECE_UNICODE = {
  'r':'‚ôú','n':'‚ôû','b':'‚ôù','q':'‚ôõ','k':'‚ôö','p':'‚ôü',
  'R':'‚ôñ','N':'‚ôò','B':'‚ôó','Q':'‚ôï','K':'‚ôî','P':'‚ôô'
};
const PIECE_VALUES = {
  'p': 1, 'n': 3, 'b': 3, 'r': 5, 'q': 9, 'k': 100,
  'P': -1, 'N': -3, 'B': -3, 'R': -5, 'Q': -9, 'K': -100
};
const TURN_TIME = 10;

const state = {
  board: [],
  selectedCell: null,
  turn: 'w',
  gameActive: false,
  moveHistory: [],
  lastMove: null,
  gameResult: null,
  timerInterval: null,
  countdown: TURN_TIME,
  playerNames: {w: 'Player 1', b: 'Player 2'},
  gamePaused: false,
  vsAI: false,
  aiDifficulty: 'easy',
  cellElements: null,
  legendTimeout: null
};

const dom = {
  status: document.getElementById('status'),
  countdown: document.getElementById('countdown'),
  chessBoard: document.getElementById('chessBoard'),
  startBtn: document.getElementById('startBtn'),
  resetBtn: document.getElementById('resetBtn'),
  pauseBtn: document.getElementById('pauseBtn'),
  player1Btn: document.getElementById('player1Btn'),
  player2Btn: document.getElementById('player2Btn'),
  player1Name: document.getElementById('player1Name'),
  player2Name: document.getElementById('player2Name'),
  modalOverlay: document.getElementById('modalOverlay'),
  player1Input: document.getElementById('player1Input'),
  player2Input: document.getElementById('player2Input'),
  saveNamesBtn: document.getElementById('saveNamesBtn'),
  modeSelection: document.getElementById('modeSelection'),
  nameInput: document.getElementById('nameInput'),
  friendModeBtn: document.getElementById('friendModeBtn'),
  aiModeBtn: document.getElementById('aiModeBtn'),
  backBtn: document.getElementById('backBtn'),
  aiDifficultySelection: document.getElementById('aiDifficultySelection'),
  aiEasyBtn: document.getElementById('aiEasyBtn'),
  aiHardBtn: document.getElementById('aiHardBtn'),
  backFromDifficultyBtn: document.getElementById('backFromDifficultyBtn'),
  legend: document.getElementById('legend'),
  timeoutModal: document.getElementById('timeoutModal'),
  timeoutMessage: document.getElementById('timeoutMessage'),
  timeoutWinner: document.getElementById('timeoutWinner')
};

const modal = {
  show() {
    dom.modeSelection.style.display = 'block';
    dom.nameInput.style.display = 'none';
    dom.aiDifficultySelection.style.display = 'none';
    dom.modalOverlay.style.display = 'flex';
  },
  hide() {
    dom.modalOverlay.style.display = 'none';
  }
};

const board = {
  init() {
    const rows = INITIAL_FEN.split(' ')[0].split('/');
    state.board = rows.map(rank => {
      const row = [];
      for (const ch of rank) {
        if (ch >= '1' && ch <= '8') {
          row.push(...Array(parseInt(ch)).fill(''));
        } else {
          row.push(ch);
        }
      }
      return row;
    });
  },
  
  render() {
    if (!state.cellElements) {
      dom.chessBoard.innerHTML = '';
      const fragment = document.createDocumentFragment();
      state.cellElements = [];
      
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const cell = document.createElement('div');
          cell.className = 'cell ' + ((r + c) % 2 === 0 ? 'white' : 'black');
          cell.dataset.r = r;
          cell.dataset.c = c;
          fragment.appendChild(cell);
          state.cellElements.push(cell);
        }
      }
      dom.chessBoard.appendChild(fragment);
    }
    
    requestAnimationFrame(() => {
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const cell = state.cellElements[r * 8 + c];
          const piece = state.board[r][c];
          
          if (piece) {
            const isWhite = piece === piece.toUpperCase();
            cell.innerHTML = `<span class="${isWhite ? 'piece-white' : 'piece-black'}">${PIECE_UNICODE[piece]}</span>`;
          } else {
            cell.innerHTML = '';
          }
          
          if (state.lastMove && 
              ((r === state.lastMove.r1 && c === state.lastMove.c1) ||
               (r === state.lastMove.r2 && c === state.lastMove.c2))) {
            cell.classList.add('lastMove');
          } else {
            cell.classList.remove('lastMove');
          }
        }
      }
    });
  },
  
  clearHighlights() {
    state.cellElements?.forEach(c => {
      c.classList.remove('highlight', 'selected', 'can-capture');
    });
  },
  
  showHighlights(r, c, moves) {
    const selectedCell = state.cellElements[r * 8 + c];
    if (selectedCell) selectedCell.classList.add('selected');
    
    for (const move of moves) {
      const cell = state.cellElements[move.r * 8 + move.c];
      if (cell) {
        const targetPiece = state.board[move.r][move.c];
        if (targetPiece) {
          cell.classList.add('can-capture');
        } else {
          cell.classList.add('highlight');
        }
      }
    }
  }
};

const chess = {
  isOwnPiece(piece, color) {
    if (!piece) return false;
    const isWhite = piece === piece.toUpperCase();
    return (isWhite && color === 'w') || (!isWhite && color === 'b');
  },
  
  isOpponentPiece(piece, isWhite) {
    if (!piece) return false;
    return (isWhite && piece === piece.toLowerCase()) || 
           (!isWhite && piece === piece.toUpperCase());
  },
  
  isOnBoard(r, c) {
    return r >= 0 && r < 8 && c >= 0 && c < 8;
  },
  
  getLegalMoves(r, c, filterCheck = true) {
    const piece = state.board[r][c];
    if (!piece) return [];
    
    const moves = [];
    const isWhite = piece === piece.toUpperCase();
    const color = isWhite ? 'w' : 'b';
    const p = piece.toLowerCase();
    
    if (p === 'p') {
      const dir = isWhite ? -1 : 1;
      if (this.isOnBoard(r + dir, c) && !state.board[r + dir][c]) {
        moves.push({r: r + dir, c});
        if ((isWhite && r === 6) || (!isWhite && r === 1)) {
          if (!state.board[r + 2 * dir][c]) {
            moves.push({r: r + 2 * dir, c});
          }
        }
      }
      for (const dc of [-1, 1]) {
        const rr = r + dir, cc = c + dc;
        if (this.isOnBoard(rr, cc) && state.board[rr][cc] && 
            this.isOpponentPiece(state.board[rr][cc], isWhite)) {
          moves.push({r: rr, c: cc});
        }
      }
    } else if (p === 'n') {
      const knightMoves = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
      for (const [dr, dc] of knightMoves) {
        const rr = r + dr, cc = c + dc;
        if (this.isOnBoard(rr, cc) && !this.isOwnPiece(state.board[rr][cc], color)) {
          moves.push({r: rr, c: cc});
        }
      }
    } else if (['b', 'r', 'q'].includes(p)) {
      const dirs = [];
      if (['b', 'q'].includes(p)) dirs.push([-1,-1],[-1,1],[1,-1],[1,1]);
      if (['r', 'q'].includes(p)) dirs.push([-1,0],[1,0],[0,-1],[0,1]);
      
      for (const [dr, dc] of dirs) {
        let rr = r + dr, cc = c + dc;
        while (this.isOnBoard(rr, cc)) {
          if (state.board[rr][cc]) {
            if (this.isOpponentPiece(state.board[rr][cc], isWhite)) {
              moves.push({r: rr, c: cc});
            }
            break;
          }
          moves.push({r: rr, c: cc});
          rr += dr;
          cc += dc;
        }
      }
    } else if (p === 'k') {
      const kingMoves = [[-1,-1],[-1,1],[1,-1],[1,1],[-1,0],[1,0],[0,-1],[0,1]];
      for (const [dr, dc] of kingMoves) {
        const rr = r + dr, cc = c + dc;
        if (this.isOnBoard(rr, cc) && !this.isOwnPiece(state.board[rr][cc], color)) {
          moves.push({r: rr, c: cc});
        }
      }
    }
    
    if (!filterCheck) return moves;
    
    return moves.filter(move => {
      const backup = state.board[r][c];
      const backupDest = state.board[move.r][move.c];
      state.board[move.r][move.c] = backup;
      state.board[r][c] = '';
      const inCheck = this.isInCheck(color);
      state.board[r][c] = backup;
      state.board[move.r][move.c] = backupDest;
      return !inCheck;
    });
  },
  
  findKing(color) {
    const kingChar = color === 'w' ? 'K' : 'k';
    for (let r = 0; r < 8; r++) {
      for (let c = 0; c < 8; c++) {
        if (state.board[r][c] === kingChar) return {r, c};
      }
    }
    return null;
  },
  
  isInCheck(color) {
    const kingPos = this.findKing(color);
    if (!kingPos) return false;
    
    const opponent = color === 'w' ? 'b' : 'w';
    for (let r = 0; r < 8; r++) {
      for (let c = 0; c < 8; c++) {
        if (state.board[r][c] && this.isOwnPiece(state.board[r][c], opponent)) {
          const moves = this.getLegalMoves(r, c, false);
          if (moves.some(m => m.r === kingPos.r && m.c === kingPos.c)) {
            return true;
          }
        }
      }
    }
    return false;
  },
  
  hasLegalMoves(color) {
    for (let r = 0; r < 8; r++) {
      for (let c = 0; c < 8; c++) {
        if (state.board[r][c] && this.isOwnPiece(state.board[r][c], color)) {
          if (this.getLegalMoves(r, c).length > 0) return true;
        }
      }
    }
    return false;
  },
  
  isCheckmateOrDraw() {
    if (!this.hasLegalMoves(state.turn)) {
      state.gameResult = this.isInCheck(state.turn) ? 'checkmate' : 'draw';
      return true;
    }
    return false;
  }
};

const ai = {
  makeMove() {
    if (!state.gameActive || state.turn === 'w' || state.gamePaused) return;
    
    const move = state.aiDifficulty === 'easy' ? this.randomMove() : this.smartMove();
    if (move) {
      game.makeMove(move.r1, move.c1, move.r2, move.c2);
      game.switchTurn();
    } else {
      game.end();
    }
  },
  
  randomMove() {
    const moves = [];
    for (let r = 0; r < 8; r++) {
      for (let c = 0; c < 8; c++) {
        if (state.board[r][c] && chess.isOwnPiece(state.board[r][c], 'b')) {
          const pieceMoves = chess.getLegalMoves(r, c);
          for (const m of pieceMoves) {
            moves.push({r1: r, c1: c, r2: m.r, c2: m.c});
          }
        }
      }
    }
    return moves[Math.floor(Math.random() * moves.length)];
  },
  
  smartMove() {
    let bestScore = -Infinity;
    let bestMove = null;
    
    for (let r = 0; r < 8; r++) {
      for (let c = 0; c < 8; c++) {
        if (state.board[r][c] && chess.isOwnPiece(state.board[r][c], 'b')) {
          const moves = chess.getLegalMoves(r, c);
          for (const m of moves) {
            const backup = state.board[r][c];
            const backupDest = state.board[m.r][m.c];
            state.board[m.r][m.c] = backup;
            state.board[r][c] = '';
            
            const score = this.evaluate();
            
            state.board[r][c] = backup;
            state.board[m.r][m.c] = backupDest;
            
            if (score > bestScore) {
              bestScore = score;
              bestMove = {r1: r, c1: c, r2: m.r, c2: m.c};
            }
          }
        }
      }
    }
    return bestMove;
  },
  
  evaluate() {
    let score = 0;
    
    for (let r = 0; r < 8; r++) {
      for (let c = 0; c < 8; c++) {
        const piece = state.board[r][c];
        if (piece) {
          score += PIECE_VALUES[piece] || 0;
          
          if (piece.toLowerCase() === 'p') {
            score += (piece === 'p' ? r * 0.1 : (7 - r) * -0.1);
          }
          
          const centerDist = Math.abs(3.5 - r) + Math.abs(3.5 - c);
          score += (piece === piece.toLowerCase() ? 1 : -1) * (7 - centerDist) * 0.05;
        }
      }
    }
    
    return score;
  }
};

const timer = {
  start() {
    if (state.gamePaused) return;
    this.reset();
    state.timerInterval = setInterval(() => {
      if (state.gamePaused) return;
      state.countdown--;
      
      // Update countdown display
      dom.countdown.textContent = 'Time: ' + state.countdown;
      
      // Update color based on time remaining
      dom.countdown.classList.remove('normal', 'medium', 'warning');
      if (state.countdown <= 3) {
        dom.countdown.classList.add('warning'); // Red
      } else if (state.countdown <= 6) {
        dom.countdown.classList.add('medium'); // Yellow
      } else {
        dom.countdown.classList.add('normal'); // Blue
      }
      
      if (state.countdown <= 0) {
        this.stop();
        game.timeout();
      }
    }, 1000);
  },
  
  stop() {
    clearInterval(state.timerInterval);
  },
  
  reset() {
    this.stop();
    state.countdown = TURN_TIME;
    dom.countdown.textContent = 'Time: ' + state.countdown;
    dom.countdown.classList.remove('medium', 'warning');
    dom.countdown.classList.add('normal');
  }
};

const game = {
  start() {
    board.init();
    state.gameActive = true;
    state.gamePaused = false;
    state.gameResult = null;
    state.turn = 'w';
    state.moveHistory = [];
    state.lastMove = null;
    state.selectedCell = null;
    
    dom.resetBtn.disabled = false;
    dom.pauseBtn.disabled = false;
    dom.pauseBtn.textContent = '‚∏èÔ∏è Pause';
    dom.startBtn.disabled = true;
    
    this.updateStatus();
    board.render();
    timer.start();
    
    state.cellElements?.forEach(c => c.classList.remove('disabled'));
    
    // Show legend for 10 seconds
    if (state.legendTimeout) {
      clearTimeout(state.legendTimeout);
    }
    dom.legend.classList.add('show');
    state.legendTimeout = setTimeout(() => {
      dom.legend.classList.remove('show');
    }, 10000);
  },
  
  makeMove(r1, c1, r2, c2) {
    state.lastMove = {r1, c1, r2, c2};
    state.board[r2][c2] = state.board[r1][c1];
    state.board[r1][c1] = '';
    state.moveHistory.push({from: {r: r1, c: c1}, to: {r: r2, c: c2}});
    board.render();
  },
  
  switchTurn() {
    state.turn = state.turn === 'w' ? 'b' : 'w';
    state.selectedCell = null;
    board.clearHighlights();
    
    if (chess.isCheckmateOrDraw()) {
      this.end();
      return;
    }
    
    this.updateStatus();
    timer.start();
    
    if (state.gameActive && state.turn === 'b' && state.vsAI) {
      setTimeout(() => ai.makeMove(), 500);
    }
  },
  
  updateStatus() {
    if (state.gamePaused) {
      dom.status.textContent = '‚∏èÔ∏è GAME PAUSED';
    } else if (state.gameResult === 'checkmate') {
      const winner = state.turn === 'w' ? state.playerNames.b : state.playerNames.w;
      dom.status.textContent = winner + ' Wins by Checkmate!';
    } else if (state.gameResult === 'draw') {
      dom.status.textContent = 'Draw - Stalemate!';
    } else if (chess.isInCheck(state.turn)) {
      const currentPlayer = state.turn === 'w' ? state.playerNames.w : state.playerNames.b;
      dom.status.textContent = 'Check! ' + currentPlayer + "'s turn";
    } else {
      const currentPlayer = state.turn === 'w' ? state.playerNames.w : state.playerNames.b;
      dom.status.textContent = currentPlayer + "'s turn";
    }
  },
  
  timeout() {
    state.gameActive = false;
    const loser = state.turn === 'w' ? state.playerNames.w : state.playerNames.b;
    const winner = state.turn === 'w' ? state.playerNames.b : state.playerNames.w;
    
    // Show timeout modal
    dom.timeoutMessage.textContent = loser + ' ran out of time!';
    dom.timeoutWinner.textContent = 'üèÜ ' + winner + ' WINS! üèÜ';
    dom.timeoutModal.classList.add('show');
    
    // Hide modal after 5 seconds
    setTimeout(() => {
      dom.timeoutModal.classList.remove('show');
    }, 5000);
    
    dom.status.textContent = winner + ' wins by timeout!';
    this.end();
  },
  
  end() {
    state.gameActive = false;
    state.gamePaused = false;
    timer.stop();
    dom.startBtn.disabled = false;
    dom.resetBtn.disabled = false;
    dom.pauseBtn.disabled = true;
    state.cellElements?.forEach(c => c.classList.add('disabled'));
    
    // Hide legend when game ends
    if (state.legendTimeout) {
      clearTimeout(state.legendTimeout);
    }
    dom.legend.classList.remove('show');
    
    // Reset countdown color
    dom.countdown.classList.remove('medium', 'warning');
    dom.countdown.classList.add('normal');
    
    this.updateStatus();
  },
  
  pause() {
    if (!state.gameActive) return;
    
    state.gamePaused = !state.gamePaused;
    
    if (state.gamePaused) {
      dom.pauseBtn.textContent = '‚ñ∂Ô∏è Resume';
      timer.stop();
      state.cellElements?.forEach(c => {
        c.style.opacity = '0.5';
        c.classList.add('disabled');
      });
    } else {
      dom.pauseBtn.textContent = '‚∏èÔ∏è Pause';
      state.cellElements?.forEach(c => {
        c.style.opacity = '1';
        c.classList.remove('disabled');
      });
      timer.start();
    }
    this.updateStatus();
  },
  
  reset() {
    this.start();
  }
};

dom.chessBoard.addEventListener('click', (e) => {
  if (!state.gameActive || state.gamePaused) return;
  
  const cell = e.target.closest('.cell');
  if (!cell) return;
  
  const r = parseInt(cell.dataset.r);
  const c = parseInt(cell.dataset.c);
  const piece = state.board[r][c];
  
  if (state.selectedCell) {
    if (state.selectedCell.r === r && state.selectedCell.c === c) {
      state.selectedCell = null;
      board.clearHighlights();
      return;
    }
    
    const moves = chess.getLegalMoves(state.selectedCell.r, state.selectedCell.c);
    if (moves.some(m => m.r === r && m.c === c)) {
      game.makeMove(state.selectedCell.r, state.selectedCell.c, r, c);
      state.selectedCell = null;
      board.clearHighlights();
      game.switchTurn();
    } else if (piece && chess.isOwnPiece(piece, state.turn)) {
      state.selectedCell = {r, c};
      board.clearHighlights();
      board.showHighlights(r, c, chess.getLegalMoves(r, c));
    } else {
      state.selectedCell = null;
      board.clearHighlights();
    }
  } else {
    if (piece && chess.isOwnPiece(piece, state.turn)) {
      state.selectedCell = {r, c};
      board.showHighlights(r, c, chess.getLegalMoves(r, c));
    }
  }
});

dom.friendModeBtn.addEventListener('click', () => {
  state.vsAI = false;
  dom.modeSelection.style.display = 'none';
  dom.nameInput.style.display = 'block';
  dom.player2Input.placeholder = 'Player 2 Name';
  dom.player2Input.disabled = false;
  dom.player2Input.value = '';
});

dom.aiModeBtn.addEventListener('click', () => {
  state.vsAI = true;
  dom.modeSelection.style.display = 'none';
  dom.aiDifficultySelection.style.display = 'block';
});

dom.aiEasyBtn.addEventListener('click', () => {
  state.aiDifficulty = 'easy';
  dom.aiDifficultySelection.style.display = 'none';
  dom.nameInput.style.display = 'block';
  dom.player2Input.value = 'AI (Easy)';
  dom.player2Input.disabled = true;
});

dom.aiHardBtn.addEventListener('click', () => {
  state.aiDifficulty = 'hard';
  dom.aiDifficultySelection.style.display = 'none';
  dom.nameInput.style.display = 'block';
  dom.player2Input.value = 'AI (Hard)';
  dom.player2Input.disabled = true;
});

dom.backFromDifficultyBtn.addEventListener('click', () => {
  dom.aiDifficultySelection.style.display = 'none';
  dom.modeSelection.style.display = 'block';
});

dom.backBtn.addEventListener('click', () => {
  dom.nameInput.style.display = 'none';
  if (state.vsAI) {
    dom.aiDifficultySelection.style.display = 'block';
  } else {
    dom.modeSelection.style.display = 'block';
  }
});

dom.saveNamesBtn.addEventListener('click', () => {
  const p1 = dom.player1Input.value.trim() || 'Player 1';
  const p2 = state.vsAI ? 
    (state.aiDifficulty === 'hard' ? 'AI (Hard)' : 'AI (Easy)') : 
    (dom.player2Input.value.trim() || 'Player 2');
  
  state.playerNames.w = p1;
  state.playerNames.b = p2;
  dom.player1Name.textContent = p1;
  dom.player2Name.textContent = p2;
  modal.hide();
  game.start();
});

dom.player1Btn.addEventListener('click', () => {
  if (!state.gameActive) {
    modal.show();
    dom.player1Input.value = state.playerNames.w;
  }
});

dom.player2Btn.addEventListener('click', () => {
  if (!state.gameActive && !state.vsAI) {
    modal.show();
    dom.player2Input.value = state.playerNames.b;
  }
});

dom.startBtn.addEventListener('click', () => modal.show());
dom.pauseBtn.addEventListener('click', () => game.pause());
dom.resetBtn.addEventListener('click', () => game.reset());

board.init();
board.render();
state.cellElements?.forEach(c => c.classList.add('disabled'));
</script>
</body>
</html>