<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>3D Sensor Visual System</title>

<style>
:root{
 --bg:#0b0e14;
 --accent:#00ffcc;
}
*{box-sizing:border-box;font-family:system-ui}
body{margin:0;background:var(--bg);color:#eaeaea}
h1{text-align:center;margin:10px}
button{
 padding:8px 14px;border:0;border-radius:8px;
 background:var(--accent);color:#000;font-weight:600;margin:4px
}
#controls{text-align:center}
#wrap{position:relative;max-width:420px;margin:10px auto}
video,canvas{width:100%;border-radius:12px}
#overlay{position:absolute;top:0;left:0;pointer-events:none}
.grid{
 display:grid;
 grid-template-columns:repeat(auto-fit,minmax(260px,1fr));
 gap:12px;padding:12px
}
.card{background:#111;border-radius:12px;padding:10px}
.value{font-size:13px;opacity:.85}
#three{height:260px}
</style>
</head>

<body>
<h1>ðŸ§Š Realtime 3D Sensor Visual</h1>

<div id="controls">
 <button onclick="saveCSV()">ðŸ’¾ CSV</button>
 <button onclick="exportPLY()">ðŸ“¦ 3D</button>
</div>

<div id="wrap">
 <video id="cam" autoplay playsinline></video>
 <canvas id="overlay"></canvas>
</div>

<div id="three"></div>

<div class="grid">
 <div class="card"><h3>Light</h3><div id="lightVal" class="value"></div><canvas id="lightGraph"></canvas></div>
 <div class="card"><h3>Microphone</h3><div id="micVal" class="value"></div><canvas id="micGraph"></canvas></div>
 <div class="card"><h3>Accelerometer</h3><div id="accVal" class="value"></div><canvas id="accGraph"></canvas></div>
 <div class="card"><h3>Gyroscope</h3><div id="gyroVal" class="value"></div></div>
 <div class="card"><h3>GPS Speed</h3><div id="gpsVal" class="value"></div></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
/* ================= FILTER ================= */
class Kalman{
 constructor(q=0.01,r=3){this.q=q;this.r=r;this.x=0;this.p=1}
 update(z){
  this.p+=this.q
  let k=this.p/(this.p+this.r)
  this.x+=k*(z-this.x)
  this.p*=(1-k)
  return this.x
 }
}

/* ================= STATE ================= */
const log=[]
const points3D=[]
const kLight=new Kalman()
const kSpeed=new Kalman()

let speed=0,posZ=0,lastT=Date.now()
let gyro={a:0,b:0,c:0}

/* ================= GRAPH ================= */
function drawGraph(ctx,data,color){
 ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height)
 ctx.strokeStyle=color;ctx.beginPath()
 let m=Math.max(...data,1)
 data.forEach((v,i)=>{
  let x=i*(ctx.canvas.width/(data.length-1))
  let y=ctx.canvas.height-(v/m)*ctx.canvas.height
  i?ctx.lineTo(x,y):ctx.moveTo(x,y)
 })
 ctx.stroke()
}

/* ================= CAMERA LIGHT ================= */
const cam=document.getElementById("cam")
const overlay=document.getElementById("overlay")
const octx=overlay.getContext("2d")
const lightCtx=lightGraph.getContext("2d")
let lightD=[]

navigator.mediaDevices.getUserMedia({video:{facingMode:"environment"}})
.then(s=>{
 cam.srcObject=s
 const c=document.createElement("canvas"),ctx=c.getContext("2d")

 setInterval(()=>{
  c.width=cam.videoWidth;c.height=cam.videoHeight
  overlay.width=c.width;overlay.height=c.height
  ctx.drawImage(cam,0,0)

  let d=ctx.getImageData(0,0,c.width,c.height).data,sum=0
  for(let i=0;i<d.length;i+=4)
   sum+=(d[i]+d[i+1]+d[i+2])/3
  let raw=sum/(d.length/4)
  let lux=kLight.update(raw)

  lightVal.textContent="Brightness ~ "+lux.toFixed(0)
  lightD.push(lux);if(lightD.length>60)lightD.shift()
  drawGraph(lightCtx,lightD,"#00ffcc")

  updatePosition(lux)
  drawAR(lux)
  log.push({t:Date.now(),light:lux,speed,gyro_a:gyro.a,gyro_b:gyro.b,gyro_c:gyro.c,z:posZ})

 },500)
})

/* ================= MIC ================= */
let micD=[],micCtx=micGraph.getContext("2d")
navigator.mediaDevices.getUserMedia({audio:true})
.then(s=>{
 const ac=new AudioContext()
 const src=ac.createMediaStreamSource(s)
 const an=ac.createAnalyser();an.fftSize=512
 src.connect(an)
 const buf=new Uint8Array(an.fftSize)
 setInterval(()=>{
  an.getByteTimeDomainData(buf)
  let sum=0
  for(let i=0;i<buf.length;i++){
   let v=(buf[i]-128)/128;sum+=v*v
  }
  let rms=Math.sqrt(sum/buf.length)
  let db=20*Math.log10(rms||0.00001)
  micVal.textContent=db.toFixed(1)+" dB"
  micD.push(Math.abs(db));if(micD.length>60)micD.shift()
  drawGraph(micCtx,micD,"#ffb300")
 },150)
})

/* ================= MOTION ================= */
let accD=[],accCtx=accGraph.getContext("2d")
addEventListener("devicemotion",e=>{
 let a=e.accelerationIncludingGravity
 if(!a)return
 let g=Math.sqrt(a.x*a.x+a.y*a.y+a.z*a.z)
 accVal.textContent=g.toFixed(2)+" m/sÂ²"
 accD.push(g);if(accD.length>60)accD.shift()
 drawGraph(accCtx,accD,"#00c8ff")
})

addEventListener("deviceorientation",e=>{
 gyro={a:e.alpha||0,b:e.beta||0,c:e.gamma||0}
 gyroVal.textContent=`Î±:${gyro.a.toFixed(1)} Î²:${gyro.b.toFixed(1)} Î³:${gyro.c.toFixed(1)}`
})

/* ================= GPS ================= */
navigator.geolocation.watchPosition(p=>{
 speed=kSpeed.update(p.coords.speed||0)
 gpsVal.textContent=(speed*3.6).toFixed(2)+" km/h"
},{enableHighAccuracy:true})

/* ================= POSITION + 3D DATA ================= */
function updatePosition(light){
 let now=Date.now()
 let dt=(now-lastT)/1000
 lastT=now
 posZ+=speed*dt

 let c=Math.min(255,Math.max(0,light))
 points3D.push({x:0,y:0,z:posZ,r:c,g:255-c,b:120})
 addPoint3D(0,0,posZ,c)
}

/* ================= AR ================= */
function drawAR(l){
 octx.clearRect(0,0,overlay.width,overlay.height)
 octx.fillStyle="#00ffcc"
 octx.font="14px monospace"
 octx.fillText(`Light:${l.toFixed(0)}`,10,20)
 octx.fillText(`Speed:${(speed*3.6).toFixed(1)} km/h`,10,40)
}

/* ================= THREE.JS ================= */
const scene=new THREE.Scene()
const camera3=new THREE.PerspectiveCamera(60,1,0.1,1000)
const renderer=new THREE.WebGLRenderer({antialias:true})
renderer.setSize(three.clientWidth,three.clientHeight)
three.appendChild(renderer.domElement)
camera3.position.z=10

const geom=new THREE.BufferGeometry()
const positions=[]
const colors=[]
const material=new THREE.PointsMaterial({size:0.15,vertexColors:true})
const cloud=new THREE.Points(geom,material)
scene.add(cloud)

function addPoint3D(x,y,z,c){
 positions.push(x,y,z)
 colors.push(c/255,(255-c)/255,0.5)
 geom.setAttribute("position",new THREE.Float32BufferAttribute(positions,3))
 geom.setAttribute("color",new THREE.Float32BufferAttribute(colors,3))
 geom.computeBoundingSphere()
}

function animate(){
 requestAnimationFrame(animate)
 renderer.render(scene,camera3)
}
animate()

/* ================= EXPORT ================= */
function saveCSV(){
 let k=new Set()
 log.forEach(r=>Object.keys(r).forEach(x=>k.add(x)))
 let h=[...k].join(",")
 let r=log.map(o=>[...k].map(x=>o[x]??"").join(","))
 let blob=new Blob([h+"\n"+r.join("\n")],{type:"text/csv"})
 let a=document.createElement("a")
 a.href=URL.createObjectURL(blob)
 a.download="sensor_log.csv";a.click()
}

function exportPLY(){
 let h=`ply
format ascii 1.0
element vertex ${points3D.length}
property float x
property float y
property float z
property uchar red
property uchar green
property uchar blue
end_header\n`
 let b=points3D.map(p=>`${p.x} ${p.y} ${p.z} ${p.r} ${p.g} ${p.b}`).join("\n")
 let blob=new Blob([h+b])
 let a=document.createElement("a")
 a.href=URL.createObjectURL(blob)
 a.download="sensor_path.ply"
 a.click()
}
</script>
</body>
</html>
