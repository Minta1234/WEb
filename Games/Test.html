<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Road Surface â€“ All Sensors Analyzer</title>

<style>
:root{--bg:#0b0e14;--accent:#00ffcc}
*{box-sizing:border-box;font-family:system-ui}
body{margin:0;background:var(--bg);color:#eaeaea}
h1{text-align:center;margin:10px}
button{
 padding:8px 14px;border:0;border-radius:8px;
 background:var(--accent);color:#000;font-weight:600;margin:4px
}
.grid{
 display:grid;
 grid-template-columns:repeat(auto-fit,minmax(260px,1fr));
 gap:12px;padding:12px
}
.card{background:#111;border-radius:12px;padding:10px}
.value{font-size:13px;opacity:.85}
canvas{width:100%;height:120px;background:#05070b;border-radius:8px}
video{display:none}
</style>
</head>

<body>
<h1>ðŸ›£ Road Surface â€“ All Sensors</h1>

<div style="text-align:center">
<button onclick="saveCSV()">ðŸ’¾ CSV</button>
<button onclick="exportPLY()">ðŸ§Š 3D</button>
</div>

<div class="grid">
<div class="card"><h3>Light</h3><div id="lightVal" class="value"></div><canvas id="lightG"></canvas></div>
<div class="card"><h3>Accelerometer (Vertical)</h3><div id="accVal" class="value"></div><canvas id="accG"></canvas></div>
<div class="card"><h3>Gyroscope</h3><div id="gyroVal" class="value"></div><canvas id="gyroG"></canvas></div>
<div class="card"><h3>Microphone (dB)</h3><div id="micVal" class="value"></div><canvas id="micG"></canvas></div>
<div class="card"><h3>GPS Speed</h3><div id="gpsVal" class="value"></div><canvas id="gpsG"></canvas></div>
<div class="card"><h3>Distance</h3><div id="distVal" class="value"></div></div>
</div>

<video id="cam" autoplay playsinline></video>

<script>
/* ================= UTIL ================= */
function draw(ctx,data,color){
 ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height)
 ctx.strokeStyle=color;ctx.beginPath()
 let m=Math.max(...data,1)
 data.forEach((v,i)=>{
  let x=i*(ctx.canvas.width/(data.length-1))
  let y=ctx.canvas.height-(v/m)*ctx.canvas.height
  i?ctx.lineTo(x,y):ctx.moveTo(x,y)
 })
 ctx.stroke()
}

/* ================= STATE ================= */
let speed=0, distance=0, lastT=Date.now()
let accZ=0, gyro={a:0,b:0,c:0}
let lastLight=0

const log=[]
const points3D=[]

/* ================= BUFFERS ================= */
const lightD=[], accD=[], gyroD=[], micD=[], gpsD=[]

/* ================= CAMERA â†’ LIGHT ================= */
const cam=document.getElementById("cam")
const lctx=lightG.getContext("2d")

navigator.mediaDevices.getUserMedia({video:{facingMode:"environment"}})
.then(s=>{
 cam.srcObject=s
 const c=document.createElement("canvas"),ctx=c.getContext("2d")
 setInterval(()=>{
  c.width=cam.videoWidth;c.height=cam.videoHeight
  ctx.drawImage(cam,0,0)
  let d=ctx.getImageData(0,0,c.width,c.height).data,sum=0
  for(let i=0;i<d.length;i+=4)
   sum+=(d[i]+d[i+1]+d[i+2])/3
  let light=sum/(d.length/4)
  lightVal.textContent=light.toFixed(0)
  lightD.push(light);if(lightD.length>60)lightD.shift()
  draw(lctx,lightD,"#00ffcc")
  updateSurface(light)
 },400)
})

/* ================= ACC ================= */
const actx=accG.getContext("2d")
addEventListener("devicemotion",e=>{
 let a=e.accelerationIncludingGravity
 if(!a)return
 accZ=a.z||0
 accVal.textContent=accZ.toFixed(2)
 accD.push(Math.abs(accZ));if(accD.length>60)accD.shift()
 draw(actx,accD,"#00c8ff")
})

/* ================= GYRO ================= */
const gctx=gyroG.getContext("2d")
addEventListener("deviceorientation",e=>{
 gyro={a:e.alpha||0,b:e.beta||0,c:e.gamma||0}
 gyroVal.textContent=`Î±:${gyro.a.toFixed(1)} Î²:${gyro.b.toFixed(1)} Î³:${gyro.c.toFixed(1)}`
 gyroD.push(Math.abs(gyro.b));if(gyroD.length>60)gyroD.shift()
 draw(gctx,gyroD,"#ffb300")
})

/* ================= MIC ================= */
const mctx=micG.getContext("2d")
navigator.mediaDevices.getUserMedia({audio:true})
.then(s=>{
 const ac=new AudioContext()
 const src=ac.createMediaStreamSource(s)
 const an=ac.createAnalyser();an.fftSize=512
 src.connect(an)
 const buf=new Uint8Array(an.fftSize)
 setInterval(()=>{
  an.getByteTimeDomainData(buf)
  let sum=0
  for(let i=0;i<buf.length;i++){
   let v=(buf[i]-128)/128;sum+=v*v
  }
  let rms=Math.sqrt(sum/buf.length)
  let db=20*Math.log10(rms||0.00001)
  micVal.textContent=db.toFixed(1)+" dB"
  micD.push(Math.abs(db));if(micD.length>60)micD.shift()
  draw(mctx,micD,"#ff5c5c")
 },150)
})

/* ================= GPS ================= */
const gpctx=gpsG.getContext("2d")
navigator.geolocation.watchPosition(p=>{
 speed=p.coords.speed||0
 gpsVal.textContent=(speed*3.6).toFixed(1)+" km/h"
 gpsD.push(speed*3.6);if(gpsD.length>60)gpsD.shift()
 draw(gpctx,gpsD,"#9cff00")
},{enableHighAccuracy:true})

/* ================= CORE ================= */
function updateSurface(light){
 let now=Date.now()
 let dt=(now-lastT)/1000
 lastT=now
 distance+=speed*dt
 distVal.textContent=distance.toFixed(1)+" m"

 let lgi=(light-lastLight)/(dt*speed||0.01)
 lastLight=light

 let z=Math.abs(accZ)*0.8 + Math.abs(lgi)*0.02 + Math.abs(micD.at(-1)||0)*0.05
 let c=Math.min(255,Math.max(0,light))

 points3D.push({x:distance,y:0,z,r:c,g:255-c,b:80})

 log.push({
  timestamp:now,
  distance_m:distance,
  speed_ms:speed,
  light:light,
  light_gradient:lgi,
  acc_z:accZ,
  gyro_alpha:gyro.a,
  gyro_beta:gyro.b,
  gyro_gamma:gyro.c,
  mic_db:micD.at(-1)||0,
  surface_z:z
 })
}

/* ================= EXPORT ================= */
function saveCSV(){
 let h=Object.keys(log[0]).join(",")
 let r=log.map(o=>Object.values(o).join(","))
 let a=document.createElement("a")
 a.href=URL.createObjectURL(new Blob([[h,...r].join("\n")]))
 a.download="road_surface_all_sensors.csv"
 a.click()
}

function exportPLY(){
 let h=
`ply
format ascii 1.0
element vertex ${points3D.length}
property float x
property float y
property float z
property uchar red
property uchar green
property uchar blue
end_header\n`
 let b=points3D.map(p=>
  `${p.x.toFixed(3)} ${p.y} ${p.z.toFixed(3)} ${p.r} ${p.g} ${p.b}`
 ).join("\n")
 let a=document.createElement("a")
 a.href=URL.createObjectURL(new Blob([h+b]))
 a.download="road_surface_3d.ply"
 a.click()
}
</script>
</body>
</html>
