<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>AR Sensor Logger 3D</title>

<style>
:root{
  --bg:#0b0e14;
  --accent:#00ffcc;
}
*{box-sizing:border-box;font-family:system-ui}
body{margin:0;background:var(--bg);color:#eaeaea}
h1{text-align:center;margin:10px 0}
button{
  padding:8px 14px;border:0;border-radius:8px;
  background:var(--accent);color:#000;font-weight:600;
  margin:4px
}
#controls{text-align:center}
#wrap{position:relative;max-width:420px;margin:10px auto}
video,canvas{width:100%;border-radius:12px}
#overlay{position:absolute;top:0;left:0;pointer-events:none}
#graph{background:#05070b;margin-top:8px}
</style>
</head>

<body>
<h1>ðŸ“¡ AR Sensor Logger + 3D</h1>

<div id="controls">
  <button onclick="saveCSV()">ðŸ’¾ Export CSV</button>
  <button onclick="exportPLY()">ðŸ§Š Export 3D (PLY)</button>
</div>

<div id="wrap">
  <video id="cam" autoplay playsinline></video>
  <canvas id="overlay"></canvas>
</div>

<canvas id="graph"></canvas>

<script>
/* ================= KALMAN FILTER ================= */
class Kalman{
 constructor(q=0.01,r=3){
  this.q=q;this.r=r;this.x=0;this.p=1
 }
 update(z){
  this.p+=this.q
  let k=this.p/(this.p+this.r)
  this.x+=k*(z-this.x)
  this.p*=(1-k)
  return this.x
 }
}

/* ================= GLOBAL STATE ================= */
const log=[]
const points3D=[]
const kLight=new Kalman()
const kSpeed=new Kalman()

let gyro={a:0,b:0,c:0}
let speedMS=0
let posZ=0
let lastT=Date.now()

/* ================= GRAPH ================= */
const gctx=graph.getContext("2d")
let gData=[]
function drawGraph(v){
 gData.push(v); if(gData.length>60) gData.shift()
 gctx.clearRect(0,0,graph.width,graph.height)
 gctx.strokeStyle="#00ffcc"; gctx.beginPath()
 let m=Math.max(...gData,1)
 gData.forEach((d,i)=>{
  let x=i*(graph.width/(gData.length-1))
  let y=graph.height-(d/m)*graph.height
  i?gctx.lineTo(x,y):gctx.moveTo(x,y)
 })
 gctx.stroke()
}

/* ================= CAMERA + LIGHT ================= */
const cam=document.getElementById("cam")
const overlay=document.getElementById("overlay")
const octx=overlay.getContext("2d")

navigator.mediaDevices.getUserMedia({video:{facingMode:{exact:"environment"}}})
.then(s=>{
 cam.srcObject=s
 const c=document.createElement("canvas"),ctx=c.getContext("2d")

 setInterval(()=>{
  c.width=cam.videoWidth;c.height=cam.videoHeight
  overlay.width=c.width;overlay.height=c.height
  graph.width=c.width;graph.height=120

  ctx.drawImage(cam,0,0)
  let d=ctx.getImageData(0,0,c.width,c.height).data,sum=0
  for(let i=0;i<d.length;i+=4)
   sum+=(d[i]+d[i+1]+d[i+2])/3

  let raw=sum/(d.length/4)
  let light=kLight.update(raw)

  updatePosition(light)
  drawAR(light)
  drawGraph(light)
  logData(light)

 },500)
})

/* ================= GYROSCOPE ================= */
if(window.DeviceOrientationEvent){
 addEventListener("deviceorientation",e=>{
  gyro={
   a:e.alpha||0,
   b:e.beta||0,
   c:e.gamma||0
  }
 })
}

/* ================= GPS SPEED ================= */
navigator.geolocation?.watchPosition(p=>{
 let s=p.coords.speed||0
 speedMS=kSpeed.update(s)
},{enableHighAccuracy:true,maximumAge:0,timeout:5000})

/* ================= POSITION + 3D ================= */
function updatePosition(light){
 let now=Date.now()
 let dt=(now-lastT)/1000
 lastT=now
 posZ+=speedMS*dt

 let c=Math.min(255,Math.max(0,light))
 points3D.push({
  x:0,y:0,z:posZ,
  r:c,g:255-c,b:120
 })
}

/* ================= AR OVERLAY ================= */
function drawAR(light){
 octx.clearRect(0,0,overlay.width,overlay.height)
 octx.fillStyle="#00ffcc"
 octx.font="15px monospace"
 octx.fillText(`Light: ${light.toFixed(0)}`,10,22)
 octx.fillText(`Speed: ${(speedMS*3.6).toFixed(1)} km/h`,10,42)
 octx.fillText(`Gyro Î±:${gyro.a.toFixed(1)}`,10,62)
 octx.fillText(`Î²:${gyro.b.toFixed(1)} Î³:${gyro.c.toFixed(1)}`,10,82)
}

/* ================= LOG ================= */
function logData(light){
 log.push({
  timestamp:Date.now(),
  light_back:light,
  gps_speed_ms:speedMS,
  gps_speed_kmh:speedMS*3.6,
  gyro_alpha:gyro.a,
  gyro_beta:gyro.b,
  gyro_gamma:gyro.c,
  z_position:posZ
 })
}

/* ================= EXPORT CSV ================= */
function saveCSV(){
 if(!log.length) return
 let h=Object.keys(log[0]).join(",")
 let r=log.map(o=>Object.values(o).join(","))
 let csv=[h,...r].join("\n")
 let b=new Blob([csv],{type:"text/csv"})
 let a=document.createElement("a")
 a.href=URL.createObjectURL(b)
 a.download="sensor_log.csv"
 a.click()
}

/* ================= EXPORT 3D (PLY) ================= */
function exportPLY(){
 let header=
`ply
format ascii 1.0
element vertex ${points3D.length}
property float x
property float y
property float z
property uchar red
property uchar green
property uchar blue
end_header\n`
 let body=points3D.map(p=>
  `${p.x} ${p.y} ${p.z.toFixed(3)} ${p.r} ${p.g} ${p.b}`
 ).join("\n")
 let b=new Blob([header+body],{type:"application/octet-stream"})
 let a=document.createElement("a")
 a.href=URL.createObjectURL(b)
 a.download="sensor_path_3d.ply"
 a.click()
}
</script>

</body>
</html>
