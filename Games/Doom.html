<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hand Controlled DOOM - Enhanced</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(180deg, #1a0000 0%, #000 100%);
            color: #ff0000;
            font-family: 'Impact', 'Arial Black', sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        #game-container {
            position: relative;
            width: 800px;
            height: 600px;
            border: 4px solid #8b0000;
            box-shadow: 0 0 40px rgba(255, 0, 0, 0.5), inset 0 0 20px rgba(0, 0, 0, 0.8);
            background: #000;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        #webcam-feed {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 160px;
            height: 120px;
            border: 2px solid #ff0000;
            opacity: 0.8;
            transform: scaleX(-1);
            z-index: 10;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
        }

        #ui-layer {
            z-index: 5;
            pointer-events: none;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 28px;
            background: rgba(139, 0, 0, 0.95);
            padding: 30px 40px;
            border: 3px solid #ff0000;
            text-align: center;
            z-index: 20;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.8);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #loading small {
            display: block;
            margin-top: 10px;
            font-size: 14px;
            color: #ffaaaa;
        }

        .weapon-sprite {
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            height: 400px;
            z-index: 4;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center bottom;
            image-rendering: pixelated;
            transition: transform 0.05s;
        }

        .muzzle-flash {
            position: absolute;
            bottom: 200px;
            left: 50%;
            transform: translateX(-50%);
            width: 150px;
            height: 150px;
            background: radial-gradient(circle, #ffff00 0%, #ff6600 30%, transparent 70%);
            opacity: 0;
            z-index: 6;
            filter: blur(5px);
        }

        .hud {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 100px;
            background: linear-gradient(to top, rgba(100, 0, 0, 0.9), transparent);
            z-index: 8;
            display: flex;
            align-items: flex-end;
            padding: 10px 20px;
            gap: 30px;
        }

        .hud-item {
            color: #ffff00;
            font-size: 24px;
            text-shadow: 2px 2px 4px #000;
            font-weight: bold;
        }

        .hud-health {
            color: #ff0000;
            font-size: 32px;
        }

        .hud-ammo {
            margin-left: auto;
            color: #00ff00;
        }

        .gesture-display {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 30px;
            border: 2px solid #ff0000;
            z-index: 10;
            font-size: 24px;
            text-align: center;
            min-width: 300px;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
        }

        .finger-count {
            color: #ffff00;
            font-size: 36px;
            font-weight: bold;
        }

        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            z-index: 7;
            pointer-events: none;
        }

        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 0, 0, 0.8);
        }

        .crosshair::before {
            width: 20px;
            height: 2px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .crosshair::after {
            width: 2px;
            height: 20px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .damage-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle, transparent 30%, rgba(255, 0, 0, 0.5));
            opacity: 0;
            z-index: 9;
            pointer-events: none;
            transition: opacity 0.2s;
        }
    </style>
</head>
<body>

    <div id="loading">
        üéÆ DOOM LOADING üéÆ
        <small>‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡∏Å‡∏•‡πâ‡∏≠‡∏á</small>
        <small style="margin-top: 5px;">1üñêÔ∏è=‡πÄ‡∏î‡∏¥‡∏ô‡∏´‡∏ô‡πâ‡∏≤ | 2üñêÔ∏è=‡∏ñ‡∏≠‡∏¢ | 3üñêÔ∏è=‡∏ã‡πâ‡∏≤‡∏¢ | 4üñêÔ∏è=‡∏Ç‡∏ß‡∏≤ | ‚úä=‡∏¢‡∏¥‡∏á</small>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <div class="weapon-sprite" id="weapon"></div>
        <div class="muzzle-flash" id="flash"></div>
        <div class="crosshair"></div>
        <div class="damage-overlay" id="damage"></div>

        <div class="hud">
            <div class="hud-item hud-health">‚ù§Ô∏è <span id="health">100</span>%</div>
            <div class="hud-item">üõ°Ô∏è <span id="armor">50</span></div>
            <div class="hud-item hud-ammo">üî´ <span id="ammo">50</span></div>
        </div>

        <div class="gesture-display">
            <div>Gesture: <span id="gesture-name" style="color:#00ff00">Waiting...</span></div>
            <div>Fingers: <span class="finger-count" id="finger-count">0</span></div>
        </div>

        <video id="webcam-feed" autoplay playsinline></video>
    </div>

<script>
    // --- Game Engine Variables ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const screenWidth = 800;
    const screenHeight = 600;

    // Enhanced map with more variety
    const mapWidth = 24;
    const mapHeight = 24;
    const worldMap = [
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,2,2,2,2,0,0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,1],
        [1,0,0,2,0,0,2,0,0,0,0,0,0,0,0,3,0,0,3,0,0,0,0,1],
        [1,0,0,2,0,0,2,0,0,0,0,0,0,0,0,3,0,0,3,0,0,0,0,1],
        [1,0,0,2,2,2,2,0,0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,4,4,4,4,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,4,0,0,4,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,4,0,0,4,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,4,4,4,4,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,6,6,6,0,0,0,0,0,0,0,0,0,0,0,6,6,6,0,0,0,1],
        [1,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,1],
        [1,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,1],
        [1,0,0,6,6,6,0,0,0,0,0,0,0,0,0,0,0,6,6,6,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    ];

    let posX = 12, posY = 12;
    let dirX = -1, dirY = 0;
    let planeX = 0, planeY = 0.66;

    let moveSpeed = 0;
    let strafeSpeed = 0;
    let rotSpeed = 0;

    // Game state
    let health = 100;
    let armor = 50;
    let ammo = 50;

    // Weapon rendering
    const weaponEl = document.getElementById('weapon');
    let weaponRecoil = 0;

    // Simple shotgun sprite (using CSS gradient as placeholder)
    weaponEl.style.background = `
        linear-gradient(180deg, 
            transparent 0%, 
            transparent 40%,
            #444 40%,
            #666 45%,
            #333 50%,
            #222 55%,
            #8b4513 60%,
            #654321 80%,
            transparent 80%
        )
    `;

    function gameLoop() {
        // Clear screen - ceiling and floor
        const horizonLine = screenHeight / 2 + Math.sin(Date.now() / 1000) * 5;
        
        // Ceiling (darker gray/red)
        const ceilGrad = ctx.createLinearGradient(0, 0, 0, horizonLine);
        ceilGrad.addColorStop(0, '#2a0a0a');
        ceilGrad.addColorStop(1, '#1a0000');
        ctx.fillStyle = ceilGrad;
        ctx.fillRect(0, 0, screenWidth, horizonLine);
        
        // Floor (brown/gray)
        const floorGrad = ctx.createLinearGradient(0, horizonLine, 0, screenHeight);
        floorGrad.addColorStop(0, '#3a2a1a');
        floorGrad.addColorStop(1, '#1a1a1a');
        ctx.fillStyle = floorGrad;
        ctx.fillRect(0, horizonLine, screenWidth, screenHeight - horizonLine);

        // Raycasting
        for (let x = 0; x < screenWidth; x += 2) {
            let cameraX = 2 * x / screenWidth - 1;
            let rayDirX = dirX + planeX * cameraX;
            let rayDirY = dirY + planeY * cameraX;

            let mapX = Math.floor(posX);
            let mapY = Math.floor(posY);

            let sideDistX, sideDistY;
            let deltaDistX = Math.abs(1 / rayDirX);
            let deltaDistY = Math.abs(1 / rayDirY);
            let perpWallDist;
            let stepX, stepY;
            let hit = 0;
            let side;

            if (rayDirX < 0) { stepX = -1; sideDistX = (posX - mapX) * deltaDistX; }
            else { stepX = 1; sideDistX = (mapX + 1.0 - posX) * deltaDistX; }

            if (rayDirY < 0) { stepY = -1; sideDistY = (posY - mapY) * deltaDistY; }
            else { stepY = 1; sideDistY = (mapY + 1.0 - posY) * deltaDistY; }

            while (hit === 0) {
                if (sideDistX < sideDistY) { 
                    sideDistX += deltaDistX; 
                    mapX += stepX; 
                    side = 0; 
                } else { 
                    sideDistY += deltaDistY; 
                    mapY += stepY; 
                    side = 1; 
                }
                if (worldMap[mapX][mapY] > 0) hit = 1;
            }

            if (side === 0) perpWallDist = (mapX - posX + (1 - stepX) / 2) / rayDirX;
            else perpWallDist = (mapY - posY + (1 - stepY) / 2) / rayDirY;

            let lineHeight = Math.floor(screenHeight / perpWallDist);
            let drawStart = -lineHeight / 2 + screenHeight / 2;
            if (drawStart < 0) drawStart = 0;
            let drawEnd = lineHeight / 2 + screenHeight / 2;
            if (drawEnd >= screenHeight) drawEnd = screenHeight - 1;

            // Wall colors (DOOM-like palette)
            let color;
            switch(worldMap[mapX][mapY]) {
                case 1: color = '#8b0000'; break; // Dark red
                case 2: color = '#654321'; break; // Brown
                case 3: color = '#4a4a4a'; break; // Gray
                case 4: color = '#2f4f2f'; break; // Dark green
                case 5: color = '#8b7355'; break; // Tan
                case 6: color = '#556b2f'; break; // Olive
                default: color = '#666';
            }

            // Shading for depth
            let shade = Math.max(0.3, 1 - perpWallDist / 20);
            if (side === 1) shade *= 0.7;

            const r = parseInt(color.slice(1, 3), 16);
            const g = parseInt(color.slice(3, 5), 16);
            const b = parseInt(color.slice(5, 7), 16);

            ctx.fillStyle = `rgb(${r * shade}, ${g * shade}, ${b * shade})`;
            ctx.fillRect(x, drawStart, 2, drawEnd - drawStart);

            // Simple texture effect
            if (perpWallDist < 10) {
                for (let i = 0; i < 3; i++) {
                    const y = drawStart + Math.random() * (drawEnd - drawStart);
                    ctx.fillStyle = `rgba(0,0,0,${0.1 * shade})`;
                    ctx.fillRect(x, y, 2, 2);
                }
            }
        }

        // Movement
        const frameMoveSpeed = moveSpeed * 0.08;
        const frameRotSpeed = rotSpeed * 0.06;
        const frameStrafeSpeed = strafeSpeed * 0.08;

        // Forward/Backward
        if (moveSpeed !== 0) {
            const newX = posX + dirX * frameMoveSpeed;
            const newY = posY + dirY * frameMoveSpeed;
            if (worldMap[Math.floor(newX)][Math.floor(posY)] === 0) posX = newX;
            if (worldMap[Math.floor(posX)][Math.floor(newY)] === 0) posY = newY;
        }

        // Strafe
        if (strafeSpeed !== 0) {
            const newX = posX + planeX * frameStrafeSpeed;
            const newY = posY + planeY * frameStrafeSpeed;
            if (worldMap[Math.floor(newX)][Math.floor(posY)] === 0) posX = newX;
            if (worldMap[Math.floor(posX)][Math.floor(newY)] === 0) posY = newY;
        }

        // Rotation
        if (rotSpeed !== 0) {
            let oldDirX = dirX;
            dirX = dirX * Math.cos(-frameRotSpeed) - dirY * Math.sin(-frameRotSpeed);
            dirY = oldDirX * Math.sin(-frameRotSpeed) + dirY * Math.cos(-frameRotSpeed);
            let oldPlaneX = planeX;
            planeX = planeX * Math.cos(-frameRotSpeed) - planeY * Math.sin(-frameRotSpeed);
            planeY = oldPlaneX * Math.sin(-frameRotSpeed) + planeY * Math.cos(-frameRotSpeed);
        }

        // Weapon recoil animation
        if (weaponRecoil > 0) {
            weaponEl.style.transform = `translateX(-50%) translateY(${weaponRecoil}px) scale(${1 + weaponRecoil / 100})`;
            weaponRecoil *= 0.8;
            if (weaponRecoil < 0.5) weaponRecoil = 0;
        } else {
            weaponEl.style.transform = 'translateX(-50%)';
        }

        requestAnimationFrame(gameLoop);
    }

    requestAnimationFrame(gameLoop);

    // --- Hand Tracking ---
    const videoElement = document.getElementById('webcam-feed');
    const gestureOutput = document.getElementById('gesture-name');
    const fingerCountEl = document.getElementById('finger-count');
    const flashElement = document.getElementById('flash');

    function countFingers(landmarks) {
        let count = 0;
        
        // Thumb (check x-axis for thumb)
        if (landmarks[4].x < landmarks[3].x) count++;
        
        // Other fingers (check y-axis)
        if (landmarks[8].y < landmarks[6].y) count++;   // Index
        if (landmarks[12].y < landmarks[10].y) count++; // Middle
        if (landmarks[16].y < landmarks[14].y) count++; // Ring
        if (landmarks[20].y < landmarks[18].y) count++; // Pinky
        
        return count;
    }

    function onResults(results) {
        document.getElementById('loading').style.display = 'none';

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            const fingerCount = countFingers(landmarks);
            
            fingerCountEl.textContent = fingerCount;

            // Reset controls
            moveSpeed = 0;
            strafeSpeed = 0;
            rotSpeed = 0;

            // Gesture mapping
            switch(fingerCount) {
                case 0: // Fist - SHOOT
                    shootGun();
                    gestureOutput.textContent = 'üî• FIRING üî•';
                    gestureOutput.style.color = '#ff0000';
                    break;
                    
                case 1: // 1 finger - FORWARD
                    moveSpeed = 1.5;
                    gestureOutput.textContent = '‚¨ÜÔ∏è FORWARD';
                    gestureOutput.style.color = '#00ff00';
                    break;
                    
                case 2: // 2 fingers - BACKWARD
                    moveSpeed = -1.5;
                    gestureOutput.textContent = '‚¨áÔ∏è BACKWARD';
                    gestureOutput.style.color = '#ffaa00';
                    break;
                    
                case 3: // 3 fingers - STRAFE LEFT
                    strafeSpeed = -1.5;
                    gestureOutput.textContent = '‚¨ÖÔ∏è STRAFE LEFT';
                    gestureOutput.style.color = '#00aaff';
                    break;
                    
                case 4: // 4 fingers - STRAFE RIGHT
                    strafeSpeed = 1.5;
                    gestureOutput.textContent = '‚û°Ô∏è STRAFE RIGHT';
                    gestureOutput.style.color = '#00aaff';
                    break;
                    
                case 5: // 5 fingers - OPEN HAND (idle)
                    gestureOutput.textContent = '‚úã READY';
                    gestureOutput.style.color = '#ffff00';
                    break;
            }

        } else {
            moveSpeed = 0;
            strafeSpeed = 0;
            rotSpeed = 0;
            gestureOutput.textContent = 'No Hand Detected';
            gestureOutput.style.color = '#888';
            fingerCountEl.textContent = '0';
        }
    }

    let canShoot = true;
    function shootGun() {
        if (!canShoot || ammo <= 0) return;
        
        canShoot = false;
        ammo--;
        document.getElementById('ammo').textContent = ammo;
        
        // Muzzle flash
        flashElement.style.opacity = 1;
        
        // Weapon recoil
        weaponRecoil = 30;
        
        // Screen shake effect
        canvas.style.transform = `translate(${Math.random() * 10 - 5}px, ${Math.random() * 10 - 5}px)`;
        
        setTimeout(() => {
            flashElement.style.opacity = 0;
            canvas.style.transform = 'translate(0, 0)';
            setTimeout(() => {
                canShoot = true;
            }, 100);
        }, 80);
    }

    // MediaPipe setup
    const hands = new Hands({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.7
    });

    hands.onResults(onResults);

    const camera = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 320,
        height: 240
    });
    
    camera.start();

</script>
</body>
    </html>
