<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hand Controlled DOOM Prototype</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body {
            background-color: #111;
            color: #0f0;
            font-family: 'Courier New', Courier, monospace;
            margin: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        #game-container {
            position: relative;
            width: 640px;
            height: 480px;
            border: 4px solid #444;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.2);
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        #webcam-feed {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 160px;
            height: 120px;
            border: 2px solid #0f0;
            opacity: 0.7;
            transform: scaleX(-1); /* ‡∏Å‡∏•‡∏±‡∏ö‡∏î‡πâ‡∏≤‡∏ô‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÉ‡∏´‡πâ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏Å‡∏£‡∏∞‡∏à‡∏Å */
            z-index: 10;
        }

        #ui-layer {
            z-index: 5;
            pointer-events: none;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border: 1px solid #0f0;
            text-align: center;
            z-index: 20;
        }

        .gun {
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 200px;
            background: url('https://upload.wikimedia.org/wikipedia/commons/thumb/1/12/Doom_shotgun.png/320px-Doom_shotgun.png') no-repeat bottom center;
            background-size: contain;
            z-index: 4;
            filter: contrast(1.2) brightness(0.8);
        }

        .muzzle-flash {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            width: 100px;
            height: 100px;
            background: radial-gradient(circle, yellow, orange, transparent);
            opacity: 0;
            z-index: 6;
        }

        .status {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.5);
            padding: 5px;
            border: 1px solid #555;
            z-index: 10;
        }
    </style>
</head>
<body>

    <div id="loading">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏à‡∏±‡∏ö‡∏°‡∏∑‡∏≠...<br><small>‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡∏Å‡∏•‡πâ‡∏≠‡∏á</small></div>

    <div id="game-container">
        <canvas id="gameCanvas" width="640" height="480"></canvas>
        
        <div class="gun" id="gun"></div>
        <div class="muzzle-flash" id="flash"></div>

        <video id="webcam-feed" autoplay playsinline></video>
        
        <div class="status">
            Health: 100% | Armor: 50%<br>
            Gesture: <span id="gesture-name" style="color:yellow">Waiting...</span>
        </div>
    </div>

<script>
    // --- 1. Mini-Doom Engine (Raycasting) ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const screenWidth = 640;
    const screenHeight = 480;

    // ‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà (1 = ‡∏Å‡∏≥‡πÅ‡∏û‡∏á, 0 = ‡∏ó‡∏≤‡∏á‡πÄ‡∏î‡∏¥‡∏ô)
    const mapWidth = 24;
    const mapHeight = 24;
    const worldMap = [
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,2,2,2,2,2,0,0,0,0,3,0,3,0,3,0,0,0,1],
        [1,0,0,0,0,0,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,2,0,0,0,2,0,0,0,0,3,0,0,0,3,0,0,0,1],
        [1,0,0,0,0,0,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,2,2,0,2,2,0,0,0,0,3,0,3,0,3,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,4,0,4,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,4,0,0,0,0,5,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,4,0,4,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,4,0,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    ];

    let posX = 22, posY = 12;  // ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
    let dirX = -1, dirY = 0;   // ‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
    let planeX = 0, planeY = 0.66; // ‡∏£‡∏∞‡∏ô‡∏≤‡∏ö‡∏Å‡∏•‡πâ‡∏≠‡∏á (FOV)

    // ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡πÄ‡∏Å‡∏°
    let moveSpeed = 0; 
    let rotSpeed = 0;
    let isShooting = false;

    function gameLoop() {
        // 1. ‡πÄ‡∏Ñ‡∏•‡∏µ‡∏¢‡∏£‡πå‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠ (‡∏û‡∏∑‡πâ‡∏ô + ‡πÄ‡∏û‡∏î‡∏≤‡∏ô)
        ctx.fillStyle = "#333"; // ‡πÄ‡∏û‡∏î‡∏≤‡∏ô
        ctx.fillRect(0, 0, screenWidth, screenHeight / 2);
        ctx.fillStyle = "#555"; // ‡∏û‡∏∑‡πâ‡∏ô
        ctx.fillRect(0, screenHeight / 2, screenWidth, screenHeight / 2);

        // 2. Raycasting Algorithm
        for (let x = 0; x < screenWidth; x += 4) { // x+=4 ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏•‡∏î‡πÇ‡∏´‡∏•‡∏î (Pixelate ‡∏ô‡∏¥‡∏î‡πÜ ‡πÅ‡∏ö‡∏ö Retro)
            let cameraX = 2 * x / screenWidth - 1;
            let rayDirX = dirX + planeX * cameraX;
            let rayDirY = dirY + planeY * cameraX;

            let mapX = Math.floor(posX);
            let mapY = Math.floor(posY);

            let sideDistX, sideDistY;
            let deltaDistX = Math.abs(1 / rayDirX);
            let deltaDistY = Math.abs(1 / rayDirY);
            let perpWallDist;
            let stepX, stepY;
            let hit = 0;
            let side;

            if (rayDirX < 0) { stepX = -1; sideDistX = (posX - mapX) * deltaDistX; }
            else { stepX = 1; sideDistX = (mapX + 1.0 - posX) * deltaDistX; }

            if (rayDirY < 0) { stepY = -1; sideDistY = (posY - mapY) * deltaDistY; }
            else { stepY = 1; sideDistY = (mapY + 1.0 - posY) * deltaDistY; }

            while (hit === 0) {
                if (sideDistX < sideDistY) { sideDistX += deltaDistX; mapX += stepX; side = 0; }
                else { sideDistY += deltaDistY; mapY += stepY; side = 1; }
                if (worldMap[mapX][mapY] > 0) hit = 1;
            }

            if (side === 0) perpWallDist = (mapX - posX + (1 - stepX) / 2) / rayDirX;
            else perpWallDist = (mapY - posY + (1 - stepY) / 2) / rayDirY;

            let lineHeight = Math.floor(screenHeight / perpWallDist);
            let drawStart = -lineHeight / 2 + screenHeight / 2;
            if (drawStart < 0) drawStart = 0;
            let drawEnd = lineHeight / 2 + screenHeight / 2;
            if (drawEnd >= screenHeight) drawEnd = screenHeight - 1;

            // ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏™‡∏µ‡∏ï‡∏≤‡∏°‡∏ä‡∏ô‡∏¥‡∏î‡∏Å‡∏≥‡πÅ‡∏û‡∏á
            let color = '#888';
            switch(worldMap[mapX][mapY]) {
                case 1: color = '#a00'; break; // ‡πÅ‡∏î‡∏á
                case 2: color = '#0a0'; break; // ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß
                case 3: color = '#00a'; break; // ‡∏ô‡πâ‡∏≥‡πÄ‡∏á‡∏¥‡∏ô
                case 4: color = '#aa0'; break; // ‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏á
                case 5: color = '#fff'; break; // ‡∏Ç‡∏≤‡∏ß
            }
            if (side === 1) { // ‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡∏î‡πâ‡∏≤‡∏ô‡∏´‡∏ô‡∏∂‡πà‡∏á‡∏°‡∏∑‡∏î‡∏•‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏î‡∏π‡∏°‡∏µ‡∏°‡∏¥‡∏ï‡∏¥
                 ctx.globalAlpha = 0.7;
            }

            ctx.fillStyle = color;
            ctx.fillRect(x, drawStart, 4, drawEnd - drawStart); // ‡∏ß‡∏≤‡∏î‡πÅ‡∏ñ‡∏ö‡∏Å‡∏ß‡πâ‡∏≤‡∏á 4px
            ctx.globalAlpha = 1.0;
        }

        // 3. ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡∏ó‡∏µ‡πà (Movement Logic)
        const frameMoveSpeed = moveSpeed * 0.05; // ‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡πÄ‡∏î‡∏¥‡∏ô
        const frameRotSpeed = rotSpeed * 0.05;   // ‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡∏´‡∏±‡∏ô

        // ‡πÄ‡∏î‡∏¥‡∏ô‡∏´‡∏ô‡πâ‡∏≤
        if (moveSpeed > 0) {
            if(worldMap[Math.floor(posX + dirX * frameMoveSpeed)][Math.floor(posY)] === 0) posX += dirX * frameMoveSpeed;
            if(worldMap[Math.floor(posX)][Math.floor(posY + dirY * frameMoveSpeed)] === 0) posY += dirY * frameMoveSpeed;
        }

        // ‡∏´‡∏°‡∏∏‡∏ô‡∏Å‡∏•‡πâ‡∏≠‡∏á
        if (rotSpeed !== 0) {
            let oldDirX = dirX;
            dirX = dirX * Math.cos(-frameRotSpeed) - dirY * Math.sin(-frameRotSpeed);
            dirY = oldDirX * Math.sin(-frameRotSpeed) + dirY * Math.cos(-frameRotSpeed);
            let oldPlaneX = planeX;
            planeX = planeX * Math.cos(-frameRotSpeed) - planeY * Math.sin(-frameRotSpeed);
            planeY = oldPlaneX * Math.sin(-frameRotSpeed) + planeY * Math.cos(-frameRotSpeed);
        }

        requestAnimationFrame(gameLoop);
    }

    // ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°‡∏•‡∏π‡∏õ
    requestAnimationFrame(gameLoop);


    // --- 2. Hand Tracking Logic (MediaPipe) ---
    const videoElement = document.getElementById('webcam-feed');
    const gestureOutput = document.getElementById('gesture-name');
    const gunElement = document.getElementById('gun');
    const flashElement = document.getElementById('flash');

    function onResults(results) {
        // ‡∏ã‡πà‡∏≠‡∏ô Loading ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÇ‡∏°‡πÄ‡∏î‡∏•‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏™‡∏£‡πá‡∏à
        document.getElementById('loading').style.display = 'none';

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            
            // --- ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏ó‡πà‡∏≤‡∏ó‡∏≤‡∏á ---
            
            // 1. ‡∏´‡∏≤‡∏à‡∏∏‡∏î‡∏®‡∏π‡∏ô‡∏¢‡πå‡∏Å‡∏•‡∏≤‡∏á‡∏°‡∏∑‡∏≠ (‡πÉ‡∏ä‡πâ Wrist + Middle Finger Base)
            const wrist = landmarks[0];
            const middleBase = landmarks[9];
            const handX = wrist.x; // 0.0 - 1.0
            
            // 2. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏Å‡∏≥‡∏°‡∏∑‡∏≠ (Fist Check)
            // ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡∏õ‡∏•‡∏≤‡∏¢‡∏ô‡∏¥‡πâ‡∏ß‡∏≠‡∏¢‡∏π‡πà‡∏ï‡πà‡∏≥‡∏Å‡∏ß‡πà‡∏≤‡∏Ç‡πâ‡∏≠‡∏ô‡∏¥‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà (‡∏á‡πà‡∏≤‡∏¢‡πÜ)
            let fingersFolded = 0;
            if (landmarks[8].y > landmarks[6].y) fingersFolded++; // ‡∏ä‡∏µ‡πâ
            if (landmarks[12].y > landmarks[10].y) fingersFolded++; // ‡∏Å‡∏•‡∏≤‡∏á
            if (landmarks[16].y > landmarks[14].y) fingersFolded++; // ‡∏ô‡∏≤‡∏á
            if (landmarks[20].y > landmarks[18].y) fingersFolded++; // ‡∏Å‡πâ‡∏≠‡∏¢
            
            const isFist = fingersFolded >= 3; 

            // --- ‡πÅ‡∏°‡∏û‡πÄ‡∏Ç‡πâ‡∏≤‡∏Å‡∏±‡∏ö‡πÄ‡∏Å‡∏° ---

            // A. ‡πÄ‡∏•‡∏µ‡πâ‡∏¢‡∏ß (Steering)
            // ‡∏ñ‡πâ‡∏≤‡∏°‡∏∑‡∏≠‡∏≠‡∏¢‡∏π‡πà‡∏ã‡πâ‡∏≤‡∏¢ (x > 0.6) ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏Å‡∏•‡∏±‡∏ö‡∏î‡πâ‡∏≤‡∏ô -> ‡πÄ‡∏•‡∏µ‡πâ‡∏¢‡∏ß‡∏ã‡πâ‡∏≤‡∏¢
            // ‡∏ñ‡πâ‡∏≤‡∏°‡∏∑‡∏≠‡∏≠‡∏¢‡∏π‡πà‡∏Ç‡∏ß‡∏≤ (x < 0.4) -> ‡πÄ‡∏•‡∏µ‡πâ‡∏¢‡∏ß‡∏Ç‡∏ß‡∏≤
            // ‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏: MediaPipe x=0 ‡∏Ñ‡∏∑‡∏≠‡∏ã‡πâ‡∏≤‡∏¢‡∏™‡∏∏‡∏î‡∏Ç‡∏≠‡∏á‡∏†‡∏≤‡∏û (‡∏Ç‡∏ß‡∏≤‡∏Ç‡∏≠‡∏á‡πÄ‡∏£‡∏≤‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡∏Å‡∏£‡∏∞‡∏à‡∏Å)
            
            if (handX > 0.65) {
                rotSpeed = -1; // ‡πÄ‡∏•‡∏µ‡πâ‡∏¢‡∏ß‡∏ã‡πâ‡∏≤‡∏¢
                gestureOutput.innerText = "Turning LEFT";
            } else if (handX < 0.35) {
                rotSpeed = 1; // ‡πÄ‡∏•‡∏µ‡πâ‡∏¢‡∏ß‡∏Ç‡∏ß‡∏≤
                gestureOutput.innerText = "Turning RIGHT";
            } else {
                rotSpeed = 0;
            }

            // B. ‡∏¢‡∏¥‡∏á ‡∏´‡∏£‡∏∑‡∏≠ ‡πÄ‡∏î‡∏¥‡∏ô (Action)
            if (isFist) {
                // ‡∏Å‡∏≥‡∏°‡∏∑‡∏≠ = ‡∏¢‡∏¥‡∏á / ‡∏´‡∏¢‡∏∏‡∏î‡πÄ‡∏î‡∏¥‡∏ô
                moveSpeed = 0;
                shootGun();
                gestureOutput.innerText = "üî• FIRING üî•";
            } else {
                // ‡πÅ‡∏ö‡∏°‡∏∑‡∏≠ = ‡πÄ‡∏î‡∏¥‡∏ô‡∏´‡∏ô‡πâ‡∏≤
                moveSpeed = 1.5; // ‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡πÄ‡∏î‡∏¥‡∏ô
                if (rotSpeed === 0) gestureOutput.innerText = "Walking Forward";
            }

        } else {
            // ‡πÑ‡∏°‡πà‡πÄ‡∏à‡∏≠‡∏°‡∏∑‡∏≠ -> ‡∏´‡∏¢‡∏∏‡∏î‡∏ó‡∏∏‡∏Å‡∏≠‡∏¢‡πà‡∏≤‡∏á
            moveSpeed = 0;
            rotSpeed = 0;
            gestureOutput.innerText = "No Hand Detected";
            gestureOutput.style.color = "gray";
        }
    }

    // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏¢‡∏¥‡∏á‡∏õ‡∏∑‡∏ô (Animation)
    let canShoot = true;
    function shootGun() {
        if (!canShoot) return;
        
        canShoot = false;
        flashElement.style.opacity = 1;
        gunElement.style.bottom = "-20px"; // ‡πÅ‡∏£‡∏á‡∏î‡∏µ‡∏î‡∏õ‡∏∑‡∏ô

        setTimeout(() => {
            flashElement.style.opacity = 0;
            gunElement.style.bottom = "0";
            canShoot = true;
        }, 150);
    }

    // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ MediaPipe
    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    hands.onResults(onResults);

    const camera = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 320,
        height: 240
    });
    
    camera.start();

</script>
</body>
  </html>
  
