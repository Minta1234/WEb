<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>micro:bit Doom Controller - Enhanced</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
    background: #0a0a0a;
    color: #0f0;
    font-family: 'Courier New', monospace;
    overflow: hidden;
}
#controls {
    position: fixed;
    top: 20px;
    left: 20px;
    z-index: 100;
    background: rgba(0,0,0,0.85);
    padding: 20px;
    border: 2px solid #0f0;
    border-radius: 8px;
    box-shadow: 0 0 20px rgba(0,255,0,0.3);
}
button {
    background: linear-gradient(135deg, #0a0 0%, #0d0 100%);
    color: #000;
    border: none;
    padding: 12px 24px;
    margin: 5px;
    cursor: pointer;
    font-weight: bold;
    font-family: inherit;
    border-radius: 5px;
    transition: all 0.2s;
    box-shadow: 0 2px 5px rgba(0,0,0,0.5);
}
button:hover { 
    background: linear-gradient(135deg, #0d0 0%, #0f0 100%);
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,255,0,0.4);
}
button:active {
    transform: translateY(0);
}
button:disabled {
    background: #333;
    color: #666;
    cursor: not-allowed;
    transform: none;
}
#status {
    display: inline-block;
    margin-left: 10px;
    padding: 8px 16px;
    border-radius: 5px;
    font-weight: bold;
    transition: all 0.3s;
}
.connected { 
    background: #0a0; 
    color: #000;
    box-shadow: 0 0 10px rgba(0,255,0,0.5);
}
.disconnected { 
    background: #a00; 
    color: #fff;
    box-shadow: 0 0 10px rgba(255,0,0,0.5);
}
#hud {
    position: fixed;
    top: 20px;
    right: 20px;
    background: rgba(0,0,0,0.85);
    padding: 20px;
    border: 2px solid #0f0;
    font-size: 20px;
    z-index: 100;
    border-radius: 8px;
    box-shadow: 0 0 20px rgba(0,255,0,0.3);
    min-width: 200px;
}
#hud > div {
    margin: 8px 0;
    padding: 5px;
    border-left: 3px solid;
    padding-left: 10px;
}
#log {
    position: fixed;
    bottom: 20px;
    left: 20px;
    width: 400px;
    height: 180px;
    background: rgba(0,0,0,0.9);
    border: 2px solid #0f0;
    padding: 15px;
    overflow-y: auto;
    font-size: 13px;
    z-index: 100;
    border-radius: 8px;
    box-shadow: 0 0 20px rgba(0,255,0,0.3);
}
#log::-webkit-scrollbar {
    width: 8px;
}
#log::-webkit-scrollbar-track {
    background: #1a1a1a;
}
#log::-webkit-scrollbar-thumb {
    background: #0a0;
    border-radius: 4px;
}
#canvas {
    display: block;
    width: 100vw;
    height: 100vh;
    background: #000;
}
.health { color: #0f0; border-color: #0f0 !important; }
.ammo { color: #ff0; border-color: #ff0 !important; }
.enemies { color: #f33; border-color: #f33 !important; }
#crosshair {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 20px;
    height: 20px;
    pointer-events: none;
    z-index: 99;
}
#crosshair::before,
#crosshair::after {
    content: '';
    position: absolute;
    background: rgba(255,0,0,0.8);
}
#crosshair::before {
    width: 2px;
    height: 20px;
    left: 9px;
}
#crosshair::after {
    width: 20px;
    height: 2px;
    top: 9px;
}
@keyframes flash {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.3; }
}
.flash {
    animation: flash 0.2s;
}
</style>
</head>
<body>
<div id="controls">
    <button id="connectBtn">CONNECT USB</button>
    <button id="disconnectBtn" disabled>DISCONNECT</button>
    <span id="status" class="disconnected">DISCONNECTED</span>
</div>

<div id="hud">
    <div class="health">HEALTH: <span id="health">100</span></div>
    <div class="ammo">AMMO: <span id="ammo">50</span></div>
    <div class="enemies">ENEMIES: <span id="enemies">5</span></div>
</div>

<div id="crosshair"></div>
<div id="log"></div>
<canvas id="canvas"></canvas>

<script>
// ========== USB SERIAL ==========
if (!("serial" in navigator)) {
    alert("Web Serial API NOT supported. Use Chrome/Edge.");
    throw new Error("NO WEB SERIAL");
}

const connectBtn = document.getElementById("connectBtn");
const disconnectBtn = document.getElementById("disconnectBtn");
const status = document.getElementById("status");
const logDiv = document.getElementById("log");

let port = null;
let reader = null;
let keepReading = true;

function log(msg) {
    const time = new Date().toLocaleTimeString();
    const entry = document.createElement('div');
    entry.innerHTML = `<span style="color:#666">[${time}]</span> ${msg}`;
    logDiv.appendChild(entry);
    logDiv.scrollTop = logDiv.scrollHeight;
    
    // Keep only last 50 entries
    while (logDiv.children.length > 50) {
        logDiv.removeChild(logDiv.firstChild);
    }
}

connectBtn.onclick = async () => {
    try {
        port = await navigator.serial.requestPort({
            filters: [{ usbVendorId: 0x0d28 }]
        });
        await port.open({ baudRate: 115200 });
        
        status.textContent = "CONNECTED";
        status.className = "connected";
        connectBtn.disabled = true;
        disconnectBtn.disabled = false;
        
        log("<span style='color:#0f0;font-weight:bold'>âœ“ USB CONNECTED - Ready to play!</span>");
        keepReading = true;
        readLoop();
    } catch (err) {
        log("<span style='color:#f00'>âœ— ERROR: " + err.message + "</span>");
    }
};

disconnectBtn.onclick = async () => {
    await disconnect();
};

async function disconnect() {
    keepReading = false;
    if (reader) {
        try {
            await reader.cancel();
            reader.releaseLock();
        } catch (e) {}
        reader = null;
    }
    if (port) {
        try { await port.close(); } catch (e) {}
        port = null;
    }
    status.textContent = "DISCONNECTED";
    status.className = "disconnected";
    connectBtn.disabled = false;
    disconnectBtn.disabled = true;
    log("<span style='color:#fa0'>âš  DISCONNECTED</span>");
}

async function readLoop() {
    try {
        const decoder = new TextDecoderStream();
        port.readable.pipeTo(decoder.writable);
        reader = decoder.readable.getReader();
        
        let buffer = "";
        while (keepReading) {
            const { value, done } = await reader.read();
            if (done) break;
            
            if (value) {
                buffer += value;
                const lines = buffer.split('\n');
                buffer = lines.pop() || "";
                
                for (const line of lines) {
                    const cmd = line.trim();
                    if (cmd) handleCommand(cmd);
                }
            }
        }
    } catch (err) {
        log("<span style='color:#f00'>âœ— Stream error: " + err.message + "</span>");
    } finally {
        await disconnect();
    }
}

// ========== GAME ENGINE ==========
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// Player state with smooth interpolation
let player = {
    x: 8,
    y: 8,
    angle: 0,
    health: 100,
    ammo: 50,
    velocity: { x: 0, y: 0 },
    angularVelocity: 0
};

// Movement state with smooth acceleration
let movement = {
    forward: 0,
    backward: 0,
    turnLeft: 0,
    turnRight: 0,
    strafeLeft: 0,
    strafeRight: 0
};

// Enhanced map with more detail
const map = [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,1,1,1,1,0,0,0,0,0,1,1,1,1,0,0,0,1],
    [1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1],
    [1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1],
    [1,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,0,1],
    [1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1],
    [1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1],
    [1,0,0,1,1,1,1,0,0,0,0,0,1,1,1,1,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];

// Enemies with AI
let enemies = [
    { x: 5, y: 5, health: 30, angle: 0 },
    { x: 14, y: 5, health: 30, angle: Math.PI },
    { x: 10, y: 9, health: 30, angle: Math.PI/2 },
    { x: 5, y: 13, health: 30, angle: 0 },
    { x: 14, y: 13, health: 30, angle: Math.PI }
];

// Particle system for effects
let particles = [];

function handleCommand(cmd) {
    log(`<span style='color:#0af'>â†’ ${cmd}</span>`);
    
    const accel = 0.8;
    
    switch(cmd) {
        case "UP":
            movement.forward = accel;
            setTimeout(() => movement.forward *= 0.3, 150);
            break;
        case "DOWN":
            movement.backward = accel;
            setTimeout(() => movement.backward *= 0.3, 150);
            break;
        case "LEFT":
            movement.turnLeft = accel;
            setTimeout(() => movement.turnLeft *= 0.3, 150);
            break;
        case "RIGHT":
            movement.turnRight = accel;
            setTimeout(() => movement.turnRight *= 0.3, 150);
            break;
        case "STRAFE_LEFT":
            movement.strafeLeft = accel;
            setTimeout(() => movement.strafeLeft *= 0.3, 150);
            break;
        case "STRAFE_RIGHT":
            movement.strafeRight = accel;
            setTimeout(() => movement.strafeRight *= 0.3, 150);
            break;
        case "FIRE":
            fire();
            break;
        case "STOP":
            movement = {
                forward: 0, backward: 0,
                turnLeft: 0, turnRight: 0,
                strafeLeft: 0, strafeRight: 0
            };
            break;
    }
}

function fire() {
    if (player.ammo <= 0) {
        log("<span style='color:#f00'>âœ— OUT OF AMMO!</span>");
        return;
    }
    
    player.ammo--;
    document.getElementById('crosshair').classList.add('flash');
    setTimeout(() => document.getElementById('crosshair').classList.remove('flash'), 200);
    
    // Muzzle flash particles
    for (let i = 0; i < 10; i++) {
        particles.push({
            x: player.x + Math.cos(player.angle) * 0.5,
            y: player.y + Math.sin(player.angle) * 0.5,
            vx: Math.cos(player.angle + (Math.random()-0.5)*0.3) * 0.2,
            vy: Math.sin(player.angle + (Math.random()-0.5)*0.3) * 0.2,
            life: 0.5,
            color: [255, 200, 0]
        });
    }
    
    // Raycast for hit detection
    let hitDist = Infinity;
    let hitEnemy = null;
    
    const range = 20;
    const step = 0.1;
    
    for (let d = 0; d < range; d += step) {
        const x = player.x + Math.cos(player.angle) * d;
        const y = player.y + Math.sin(player.angle) * d;
        
        // Check wall hit
        if (map[Math.floor(y)] && map[Math.floor(y)][Math.floor(x)]) {
            break;
        }
        
        // Check enemy hit
        for (let i = 0; i < enemies.length; i++) {
            const e = enemies[i];
            const dist = Math.sqrt((e.x - x)**2 + (e.y - y)**2);
            
            if (dist < 0.5 && d < hitDist) {
                hitDist = d;
                hitEnemy = i;
            }
        }
    }
    
    if (hitEnemy !== null) {
        const e = enemies[hitEnemy];
        const damage = Math.floor(Math.random() * 20) + 20;
        e.health -= damage;
        
        log(`<span style='color:#f80'>ðŸŽ¯ HIT! -${damage} damage (${e.health} HP remaining)</span>`);
        
        // Blood particles
        for (let i = 0; i < 15; i++) {
            particles.push({
                x: e.x,
                y: e.y,
                vx: (Math.random()-0.5) * 0.15,
                vy: (Math.random()-0.5) * 0.15,
                life: 1,
                color: [200, 0, 0]
            });
        }
        
        if (e.health <= 0) {
            enemies.splice(hitEnemy, 1);
            log("<span style='color:#0f0;font-weight:bold'>ðŸ’€ ENEMY ELIMINATED!</span>");
            
            // Death explosion
            for (let i = 0; i < 30; i++) {
                particles.push({
                    x: e.x,
                    y: e.y,
                    vx: (Math.random()-0.5) * 0.3,
                    vy: (Math.random()-0.5) * 0.3,
                    life: 1.5,
                    color: [Math.random()*100+155, 0, 0]
                });
            }
        }
    }
    
    updateHUD();
}

function updateHUD() {
    document.getElementById("health").textContent = player.health;
    document.getElementById("ammo").textContent = player.ammo;
    document.getElementById("enemies").textContent = enemies.length;
}

let lastTime = performance.now();

function gameLoop(currentTime) {
    const dt = Math.min((currentTime - lastTime) / 1000, 0.1);
    lastTime = currentTime;
    
    // Smooth movement with physics
    const maxSpeed = 3.5;
    const maxTurnSpeed = 2.5;
    const friction = 0.85;
    
    // Apply movement forces
    const moveForce = 0.15;
    const turnForce = 0.12;
    
    if (movement.forward > 0.01) {
        player.velocity.x += Math.cos(player.angle) * moveForce * movement.forward;
        player.velocity.y += Math.sin(player.angle) * moveForce * movement.forward;
        movement.forward *= 0.9;
    }
    
    if (movement.backward > 0.01) {
        player.velocity.x -= Math.cos(player.angle) * moveForce * movement.backward;
        player.velocity.y -= Math.sin(player.angle) * moveForce * movement.backward;
        movement.backward *= 0.9;
    }
    
    if (movement.strafeLeft > 0.01) {
        player.velocity.x += Math.cos(player.angle - Math.PI/2) * moveForce * movement.strafeLeft;
        player.velocity.y += Math.sin(player.angle - Math.PI/2) * moveForce * movement.strafeLeft;
        movement.strafeLeft *= 0.9;
    }
    
    if (movement.strafeRight > 0.01) {
        player.velocity.x += Math.cos(player.angle + Math.PI/2) * moveForce * movement.strafeRight;
        player.velocity.y += Math.sin(player.angle + Math.PI/2) * moveForce * movement.strafeRight;
        movement.strafeRight *= 0.9;
    }
    
    if (movement.turnLeft > 0.01) {
        player.angularVelocity -= turnForce * movement.turnLeft;
        movement.turnLeft *= 0.9;
    }
    
    if (movement.turnRight > 0.01) {
        player.angularVelocity += turnForce * movement.turnRight;
        movement.turnRight *= 0.9;
    }
    
    // Apply friction
    player.velocity.x *= friction;
    player.velocity.y *= friction;
    player.angularVelocity *= friction;
    
    // Clamp speeds
    const speed = Math.sqrt(player.velocity.x**2 + player.velocity.y**2);
    if (speed > maxSpeed) {
        player.velocity.x *= maxSpeed / speed;
        player.velocity.y *= maxSpeed / speed;
    }
    
    player.angularVelocity = Math.max(-maxTurnSpeed, Math.min(maxTurnSpeed, player.angularVelocity));
    
    // Apply velocities with collision
    const newX = player.x + player.velocity.x * dt;
    const newY = player.y + player.velocity.y * dt;
    
    const margin = 0.2;
    if (!map[Math.floor(newY)][Math.floor(newX + Math.sign(player.velocity.x) * margin)]) {
        player.x = newX;
    } else {
        player.velocity.x = 0;
    }
    
    if (!map[Math.floor(newY + Math.sign(player.velocity.y) * margin)][Math.floor(newX)]) {
        player.y = newY;
    } else {
        player.velocity.y = 0;
    }
    
    player.angle += player.angularVelocity * dt;
    
    // Update particles
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.life -= dt;
        
        if (p.life <= 0) {
            particles.splice(i, 1);
        }
    }
    
    render();
    requestAnimationFrame(gameLoop);
}

function render() {
    const w = canvas.width;
    const h = canvas.height;
    
    // Sky gradient
    const skyGrad = ctx.createLinearGradient(0, 0, 0, h/2);
    skyGrad.addColorStop(0, '#1a0a0a');
    skyGrad.addColorStop(1, '#3a1a1a');
    ctx.fillStyle = skyGrad;
    ctx.fillRect(0, 0, w, h/2);
    
    // Floor gradient
    const floorGrad = ctx.createLinearGradient(0, h/2, 0, h);
    floorGrad.addColorStop(0, '#1a1a0a');
    floorGrad.addColorStop(1, '#0a0a0a');
    ctx.fillStyle = floorGrad;
    ctx.fillRect(0, h/2, w, h/2);
    
    // Raycasting
    const fov = Math.PI / 3;
    const rays = 160;
    const zbuffer = [];
    
    for (let i = 0; i < rays; i++) {
        const rayAngle = player.angle - fov/2 + (fov * i / rays);
        
        let dist = 0;
        let hit = false;
        const stepSize = 0.03;
        let hitX, hitY;
        
        while (!hit && dist < 25) {
            dist += stepSize;
            hitX = player.x + Math.cos(rayAngle) * dist;
            hitY = player.y + Math.sin(rayAngle) * dist;
            
            if (map[Math.floor(hitY)] && map[Math.floor(hitY)][Math.floor(hitX)]) {
                hit = true;
            }
        }
        
        zbuffer[i] = dist;
        
        // Fix fisheye
        dist *= Math.cos(rayAngle - player.angle);
        
        const wallHeight = (h / dist) * 2.5;
        const brightness = Math.max(0, 255 - dist * 15);
        
        // Add subtle texture variation
        const texVar = ((hitX + hitY) * 10) % 20 - 10;
        const r = brightness + texVar;
        const g = brightness * 0.5 + texVar * 0.5;
        
        ctx.fillStyle = `rgb(${r}, ${g}, 0)`;
        ctx.fillRect(
            i * (w / rays),
            (h - wallHeight) / 2,
            Math.ceil(w / rays) + 1,
            wallHeight
        );
        
        // Add shading on top/bottom
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(i * (w / rays), (h - wallHeight) / 2, Math.ceil(w / rays) + 1, 2);
        ctx.fillRect(i * (w / rays), (h + wallHeight) / 2 - 2, Math.ceil(w / rays) + 1, 2);
    }
    
    // Draw enemies with proper depth sorting
    const enemySprites = [];
    
    enemies.forEach((enemy, idx) => {
        const dx = enemy.x - player.x;
        const dy = enemy.y - player.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        let angle = Math.atan2(dy, dx) - player.angle;
        
        // Normalize angle
        while (angle > Math.PI) angle -= 2 * Math.PI;
        while (angle < -Math.PI) angle += 2 * Math.PI;
        
        if (Math.abs(angle) < fov/2 + 0.2 && dist < 20) {
            enemySprites.push({ enemy, dist, angle, idx });
        }
    });
    
    // Sort by distance (far to near)
    enemySprites.sort((a, b) => b.dist - a.dist);
    
    // Draw sprites
    enemySprites.forEach(({ enemy, dist, angle }) => {
        const size = (h / dist) * 0.8;
        const screenX = w/2 + (angle / (fov/2)) * (w/2);
        
        // Check if behind wall using zbuffer
        const rayIdx = Math.floor((angle / fov + 0.5) * rays);
        if (rayIdx >= 0 && rayIdx < rays && dist < zbuffer[rayIdx]) {
            const healthPercent = enemy.health / 30;
            
            // Draw enemy body with gradient
            const grad = ctx.createRadialGradient(screenX, h/2, 0, screenX, h/2, size/2);
            grad.addColorStop(0, `rgba(255,${healthPercent*100},0,1)`);
            grad.addColorStop(1, `rgba(200,0,0,0.8)`);
            
            ctx.fillStyle = grad;
            ctx.fillRect(screenX - size/2, h/2 - size/2, size, size);
            
            // Draw enemy "eyes"
            ctx.fillStyle = '#ff0';
            ctx.fillRect(screenX - size/3, h/2 - size/4, size/6, size/8);
            ctx.fillRect(screenX + size/6, h/2 - size/4, size/6, size/8);
            
            // Health bar
            const barWidth = size;
            const barHeight = 4;
            ctx.fillStyle = '#300';
            ctx.fillRect(screenX - barWidth/2, h/2 + size/2 + 5, barWidth, barHeight);
            ctx.fillStyle = healthPercent > 0.5 ? '#0f0' : healthPercent > 0.25 ? '#ff0' : '#f00';
            ctx.fillRect(screenX - barWidth/2, h/2 + size/2 + 5, barWidth * healthPercent, barHeight);
        }
    });
    
    // Draw particles
    particles.forEach(p => {
        const dx = p.x - player.x;
        const dy = p.y - player.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        let angle = Math.atan2(dy, dx) - player.angle;
        
        while (angle > Math.PI) angle -= 2 * Math.PI;
        while (angle < -Math.PI) angle += 2 * Math.PI;
        
        if (Math.abs(angle) < fov/2 + 0.5 && dist < 20) {
            const size = Math.max(2, (h / dist) * 0.1);
            const screenX = w/2 + (angle / (fov/2)) * (w/2);
            const screenY = h/2;
            
            ctx.fillStyle = `rgba(${p.color[0]},${p.color[1]},${p.color[2]},${p.life})`;
            ctx.fillRect(screenX - size/2, screenY - size/2, size, size);
        }
    });
}

// Start game
log("<span style='color:#0af;font-weight:bold'>ðŸŽ® DOOM Controller Ready!</span>");
log("Connect your micro:bit via USB to start playing.");
gameLoop(performance.now());

window.addEventListener('beforeunload', disconnect);
</script>
</body>
</html>
