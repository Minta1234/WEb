<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>micro:bit Doom Controller</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
    background: #1a1a1a;
    color: #0f0;
    font-family: 'Courier New', monospace;
    overflow: hidden;
}
#controls {
    position: fixed;
    top: 10px;
    left: 10px;
    z-index: 100;
    background: rgba(0,0,0,0.8);
    padding: 15px;
    border: 2px solid #0f0;
    border-radius: 5px;
}
button {
    background: #0a0;
    color: #000;
    border: none;
    padding: 10px 20px;
    margin: 5px;
    cursor: pointer;
    font-weight: bold;
    font-family: inherit;
    border-radius: 3px;
}
button:hover { background: #0f0; }
button:disabled {
    background: #555;
    color: #888;
    cursor: not-allowed;
}
#status {
    display: inline-block;
    margin-left: 10px;
    padding: 5px 10px;
    border-radius: 3px;
}
.connected { background: #0a0; color: #000; }
.disconnected { background: #a00; color: #fff; }
#hud {
    position: fixed;
    top: 10px;
    right: 10px;
    background: rgba(0,0,0,0.8);
    padding: 15px;
    border: 2px solid #0f0;
    font-size: 18px;
    z-index: 100;
}
#log {
    position: fixed;
    bottom: 10px;
    left: 10px;
    width: 350px;
    height: 150px;
    background: rgba(0,0,0,0.9);
    border: 2px solid #0f0;
    padding: 10px;
    overflow-y: auto;
    font-size: 12px;
    z-index: 100;
}
#canvas {
    display: block;
    width: 100vw;
    height: 100vh;
    background: #000;
}
.health { color: #0f0; }
.ammo { color: #ff0; }
</style>
</head>
<body>
<div id="controls">
    <button id="connectBtn">CONNECT USB</button>
    <button id="disconnectBtn" disabled>DISCONNECT</button>
    <span id="status" class="disconnected">DISCONNECTED</span>
</div>

<div id="hud">
    <div class="health">HEALTH: <span id="health">100</span></div>
    <div class="ammo">AMMO: <span id="ammo">50</span></div>
    <div>ENEMIES: <span id="enemies">5</span></div>
</div>

<div id="log"></div>
<canvas id="canvas"></canvas>

<script>
// ========== USB SERIAL ==========
if (!("serial" in navigator)) {
    alert("Web Serial API NOT supported. Use Chrome/Edge.");
    throw new Error("NO WEB SERIAL");
}

const connectBtn = document.getElementById("connectBtn");
const disconnectBtn = document.getElementById("disconnectBtn");
const status = document.getElementById("status");
const logDiv = document.getElementById("log");

let port = null;
let reader = null;
let keepReading = true;

function log(msg) {
    const time = new Date().toLocaleTimeString();
    logDiv.innerHTML += `[${time}] ${msg}<br>`;
    logDiv.scrollTop = logDiv.scrollHeight;
}

connectBtn.onclick = async () => {
    try {
        port = await navigator.serial.requestPort({
            filters: [{ usbVendorId: 0x0d28 }]
        });
        await port.open({ baudRate: 115200 });
        
        status.textContent = "CONNECTED";
        status.className = "connected";
        connectBtn.disabled = true;
        disconnectBtn.disabled = false;
        
        log("USB CONNECTED - Ready to play!");
        keepReading = true;
        readLoop();
    } catch (err) {
        log("ERROR: " + err.message);
    }
};

disconnectBtn.onclick = async () => {
    await disconnect();
};

async function disconnect() {
    keepReading = false;
    if (reader) {
        try {
            await reader.cancel();
            reader.releaseLock();
        } catch (e) {}
        reader = null;
    }
    if (port) {
        try { await port.close(); } catch (e) {}
        port = null;
    }
    status.textContent = "DISCONNECTED";
    status.className = "disconnected";
    connectBtn.disabled = false;
    disconnectBtn.disabled = true;
    log("DISCONNECTED");
}

async function readLoop() {
    try {
        const decoder = new TextDecoderStream();
        port.readable.pipeTo(decoder.writable);
        reader = decoder.readable.getReader();
        
        let buffer = "";
        while (keepReading) {
            const { value, done } = await reader.read();
            if (done) break;
            
            if (value) {
                buffer += value;
                const lines = buffer.split('\n');
                buffer = lines.pop() || "";
                
                for (const line of lines) {
                    const cmd = line.trim();
                    if (cmd) handleCommand(cmd);
                }
            }
        }
    } catch (err) {
        log("Stream error: " + err.message);
    } finally {
        await disconnect();
    }
}

// ========== GAME ENGINE ==========
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// Player state
let player = {
    x: 8,
    y: 8,
    angle: 0,
    health: 100,
    ammo: 50
};

// Movement state
let movement = {
    forward: false,
    backward: false,
    turnLeft: false,
    turnRight: false,
    strafeLeft: false,
    strafeRight: false
};

// Simple map (1 = wall, 0 = empty)
const map = [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,1,1,1,0,0,0,0,1,1,1,0,0,1],
    [1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1],
    [1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1],
    [1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1],
    [1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1],
    [1,0,0,1,1,1,0,0,0,0,1,1,1,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];

// Enemies
let enemies = [
    { x: 4, y: 4, health: 30 },
    { x: 12, y: 4, health: 30 },
    { x: 8, y: 8, health: 30 },
    { x: 4, y: 12, health: 30 },
    { x: 12, y: 12, health: 30 }
];

function handleCommand(cmd) {
    log("CMD: " + cmd);
    
    switch(cmd) {
        case "UP":
            movement.forward = true;
            setTimeout(() => movement.forward = false, 100);
            break;
        case "DOWN":
            movement.backward = true;
            setTimeout(() => movement.backward = false, 100);
            break;
        case "LEFT":
            movement.turnLeft = true;
            setTimeout(() => movement.turnLeft = false, 100);
            break;
        case "RIGHT":
            movement.turnRight = true;
            setTimeout(() => movement.turnRight = false, 100);
            break;
        case "STRAFE_LEFT":
            movement.strafeLeft = true;
            setTimeout(() => movement.strafeLeft = false, 100);
            break;
        case "STRAFE_RIGHT":
            movement.strafeRight = true;
            setTimeout(() => movement.strafeRight = false, 100);
            break;
        case "FIRE":
            fire();
            break;
        case "STOP":
            movement = {
                forward: false, backward: false,
                turnLeft: false, turnRight: false,
                strafeLeft: false, strafeRight: false
            };
            break;
    }
}

function fire() {
    if (player.ammo <= 0) {
        log("OUT OF AMMO!");
        return;
    }
    
    player.ammo--;
    
    // Check if enemy in front
    const range = 5;
    const targetX = player.x + Math.cos(player.angle) * range;
    const targetY = player.y + Math.sin(player.angle) * range;
    
    for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        const dist = Math.sqrt((e.x - targetX)**2 + (e.y - targetY)**2);
        
        if (dist < 1.5) {
            e.health -= 30;
            log("HIT! Enemy health: " + e.health);
            
            if (e.health <= 0) {
                enemies.splice(i, 1);
                log("ENEMY ELIMINATED!");
            }
            break;
        }
    }
    
    updateHUD();
}

function updateHUD() {
    document.getElementById("health").textContent = player.health;
    document.getElementById("ammo").textContent = player.ammo;
    document.getElementById("enemies").textContent = enemies.length;
}

function gameLoop() {
    // Movement
    const moveSpeed = 0.1;
    const turnSpeed = 0.05;
    
    if (movement.forward) {
        const newX = player.x + Math.cos(player.angle) * moveSpeed;
        const newY = player.y + Math.sin(player.angle) * moveSpeed;
        if (!map[Math.floor(newY)][Math.floor(newX)]) {
            player.x = newX;
            player.y = newY;
        }
    }
    
    if (movement.backward) {
        const newX = player.x - Math.cos(player.angle) * moveSpeed;
        const newY = player.y - Math.sin(player.angle) * moveSpeed;
        if (!map[Math.floor(newY)][Math.floor(newX)]) {
            player.x = newX;
            player.y = newY;
        }
    }
    
    if (movement.turnLeft) player.angle -= turnSpeed;
    if (movement.turnRight) player.angle += turnSpeed;
    
    if (movement.strafeLeft) {
        const newX = player.x + Math.cos(player.angle - Math.PI/2) * moveSpeed;
        const newY = player.y + Math.sin(player.angle - Math.PI/2) * moveSpeed;
        if (!map[Math.floor(newY)][Math.floor(newX)]) {
            player.x = newX;
            player.y = newY;
        }
    }
    
    if (movement.strafeRight) {
        const newX = player.x + Math.cos(player.angle + Math.PI/2) * moveSpeed;
        const newY = player.y + Math.sin(player.angle + Math.PI/2) * moveSpeed;
        if (!map[Math.floor(newY)][Math.floor(newX)]) {
            player.x = newX;
            player.y = newY;
        }
    }
    
    render();
    requestAnimationFrame(gameLoop);
}

function render() {
    // Clear
    ctx.fillStyle = "#333";
    ctx.fillRect(0, 0, canvas.width, canvas.height/2);
    ctx.fillStyle = "#222";
    ctx.fillRect(0, canvas.height/2, canvas.width, canvas.height/2);
    
    // Raycasting
    const fov = Math.PI / 3;
    const rays = 120;
    
    for (let i = 0; i < rays; i++) {
        const rayAngle = player.angle - fov/2 + (fov * i / rays);
        
        let dist = 0;
        let hit = false;
        const stepSize = 0.05;
        
        while (!hit && dist < 20) {
            dist += stepSize;
            const x = player.x + Math.cos(rayAngle) * dist;
            const y = player.y + Math.sin(rayAngle) * dist;
            
            if (map[Math.floor(y)] && map[Math.floor(y)][Math.floor(x)]) {
                hit = true;
            }
        }
        
        // Fix fisheye
        dist *= Math.cos(rayAngle - player.angle);
        
        const wallHeight = (canvas.height / dist) * 2;
        const shade = Math.max(0, 255 - dist * 30);
        
        ctx.fillStyle = `rgb(${shade}, ${shade/2}, 0)`;
        ctx.fillRect(
            i * (canvas.width / rays),
            (canvas.height - wallHeight) / 2,
            canvas.width / rays + 1,
            wallHeight
        );
    }
    
    // Draw enemies
    enemies.forEach(enemy => {
        const dx = enemy.x - player.x;
        const dy = enemy.y - player.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const angle = Math.atan2(dy, dx) - player.angle;
        
        if (Math.abs(angle) < fov/2 && dist < 15) {
            const size = (canvas.height / dist) * 0.5;
            const x = canvas.width/2 + (angle / (fov/2)) * (canvas.width/2);
            
            ctx.fillStyle = "#f00";
            ctx.fillRect(x - size/2, canvas.height/2 - size/2, size, size);
        }
    });
}

// Start game
log("Game ready! Connect micro:bit to start.");
gameLoop();

window.addEventListener('beforeunload', disconnect);
</script>
</body>
</html>
